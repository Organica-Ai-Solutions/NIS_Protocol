"""
NIS Protocol Curiosity Engine

This module implements a sophisticated curiosity-driven exploration and learning system
that generates intrinsic motivation, detects novelty, and drives autonomous goal formation.
"""

import logging
import time
import math
import random
from typing import Dict, Any, List, Optional, Tuple, Set
from dataclasses import dataclass
from enum import Enum
from collections import defaultdict, deque

from ...core.agent import NISAgent, NISLayer
from ...memory.memory_manager import MemoryManager


class CuriosityType(Enum):
    """Types of curiosity mechanisms."""
    NOVELTY_SEEKING = "novelty_seeking"
    KNOWLEDGE_GAP = "knowledge_gap"
    PREDICTION_ERROR = "prediction_error"
    COMPETENCE_BUILDING = "competence_building"
    SOCIAL_CURIOSITY = "social_curiosity"
    CREATIVE_EXPLORATION = "creative_exploration"


class ExplorationStrategy(Enum):
    """Exploration strategies for curiosity-driven behavior."""
    RANDOM_EXPLORATION = "random"
    DIRECTED_EXPLORATION = "directed"
    SYSTEMATIC_EXPLORATION = "systematic"
    SOCIAL_EXPLORATION = "social"
    CREATIVE_EXPLORATION = "creative"


@dataclass
class CuriositySignal:
    """Curiosity signal with motivation strength."""
    curiosity_type: CuriosityType
    target: str
    motivation_strength: float
    novelty_score: float
    knowledge_gap_score: float
    prediction_error: float
    exploration_value: float
    timestamp: float
    context: Dict[str, Any]


@dataclass
class ExplorationGoal:
    """Goal generated by curiosity engine."""
    goal_id: str
    goal_type: str
    target: str
    exploration_strategy: ExplorationStrategy
    curiosity_signals: List[CuriositySignal]
    expected_learning: Dict[str, float]
    resource_requirements: Dict[str, Any]
    success_criteria: Dict[str, Any]
    priority: float
    created_timestamp: float


@dataclass
class LearningOutcome:
    """Result of curiosity-driven exploration."""
    exploration_goal_id: str
    knowledge_gained: Dict[str, Any]
    skills_developed: List[str]
    novelty_discovered: float
    prediction_accuracy_improvement: float
    competence_increase: float
    surprise_level: float
    satisfaction_score: float


class CuriosityEngine(NISAgent):
    """Drives exploration, learning, and goal generation through intrinsic motivation."""
    
    def __init__(
        self,
        agent_id: str = "curiosity_engine",
        description: str = "Curiosity-driven exploration and learning agent"
    ):
        super().__init__(agent_id, NISLayer.GOALS, description)
        self.logger = logging.getLogger(f"nis.{agent_id}")
        
        # Initialize memory for curiosity tracking
        self.memory = MemoryManager()
        
        # Curiosity parameters
        self.base_curiosity_level = 0.7
        self.novelty_threshold = 0.6
        self.knowledge_gap_threshold = 0.5
        self.prediction_error_threshold = 0.4
        self.exploration_decay_rate = 0.95
        
        # Curiosity type weights
        self.curiosity_weights = {
            CuriosityType.NOVELTY_SEEKING: 1.0,
            CuriosityType.KNOWLEDGE_GAP: 0.9,
            CuriosityType.PREDICTION_ERROR: 0.8,
            CuriosityType.COMPETENCE_BUILDING: 0.7,
            CuriosityType.SOCIAL_CURIOSITY: 0.6,
            CuriosityType.CREATIVE_EXPLORATION: 0.8
        }
        
        # Exploration strategy preferences
        self.strategy_preferences = {
            ExplorationStrategy.RANDOM_EXPLORATION: 0.3,
            ExplorationStrategy.DIRECTED_EXPLORATION: 0.8,
            ExplorationStrategy.SYSTEMATIC_EXPLORATION: 0.7,
            ExplorationStrategy.SOCIAL_EXPLORATION: 0.6,
            ExplorationStrategy.CREATIVE_EXPLORATION: 0.9
        }
        
        # Curiosity state tracking
        self.active_curiosity_signals: List[CuriositySignal] = []
        self.exploration_history: deque = deque(maxlen=1000)
        self.knowledge_map: Dict[str, Dict[str, Any]] = defaultdict(dict)
        self.competence_levels: Dict[str, float] = defaultdict(float)
        self.prediction_models: Dict[str, Dict[str, Any]] = defaultdict(dict)
        
        # Learning and satisfaction tracking
        self.learning_outcomes: List[LearningOutcome] = []
        self.satisfaction_history: deque = deque(maxlen=100)
        self.curiosity_satisfaction_score = 0.5
        
        # Exploration goals
        self.active_exploration_goals: List[ExplorationGoal] = []
        self.completed_exploration_goals: List[ExplorationGoal] = []
        
        self.logger.info(f"Initialized {self.__class__.__name__} with base curiosity level {self.base_curiosity_level}")
    
    def process(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Process curiosity-related requests."""
        start_time = self._start_processing_timer()
        
        try:
            operation = message.get("operation", "generate_curiosity")
            
            if operation == "generate_curiosity":
                result = self._generate_curiosity_signals(message)
            elif operation == "create_exploration_goals":
                result = self._create_exploration_goals(message)
            elif operation == "evaluate_novelty":
                result = self._evaluate_novelty(message)
            elif operation == "assess_knowledge_gaps":
                result = self._assess_knowledge_gaps(message)
            elif operation == "update_learning_outcome":
                result = self._update_learning_outcome(message)
            elif operation == "get_curiosity_state":
                result = self._get_curiosity_state(message)
            elif operation == "adjust_curiosity_parameters":
                result = self._adjust_curiosity_parameters(message)
            else:
                raise ValueError(f"Unknown operation: {operation}")
            
            # Update emotional state based on curiosity and satisfaction
            emotional_state = self._assess_curiosity_emotional_impact(result)
            
            response = self._create_response(
                "success",
                result,
                {"operation": operation, "curiosity_level": self.base_curiosity_level},
                emotional_state
            )
            
        except Exception as e:
            self.logger.error(f"Error in curiosity engine: {str(e)}")
            response = self._create_response(
                "error",
                {"error": str(e)},
                {"operation": operation}
            )
        
        finally:
            self._end_processing_timer(start_time)
        
        return response
    
    def _generate_curiosity_signals(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Generate curiosity signals based on current state and observations."""
        observations = message.get("observations", [])
        context = message.get("context", {})
        
        new_curiosity_signals = []
        
        # Process each observation for curiosity triggers
        for observation in observations:
            signals = self._analyze_observation_for_curiosity(observation, context)
            new_curiosity_signals.extend(signals)
        
        # Generate intrinsic curiosity signals
        intrinsic_signals = self._generate_intrinsic_curiosity(context)
        new_curiosity_signals.extend(intrinsic_signals)
        
        # Filter and prioritize signals
        filtered_signals = self._filter_and_prioritize_signals(new_curiosity_signals)
        
        # Update active curiosity signals
        self.active_curiosity_signals.extend(filtered_signals)
        self._decay_curiosity_signals()
        
        # Store curiosity signals in memory
        for signal in filtered_signals:
            self._store_curiosity_signal(signal)
        
        return {
            "new_curiosity_signals": len(filtered_signals),
            "total_active_signals": len(self.active_curiosity_signals),
            "curiosity_signals": [signal.__dict__ for signal in filtered_signals],
            "curiosity_level": self._calculate_current_curiosity_level(),
            "top_curiosity_targets": self._get_top_curiosity_targets()
        }
    
    def _analyze_observation_for_curiosity(
        self,
        observation: Dict[str, Any],
        context: Dict[str, Any]
    ) -> List[CuriositySignal]:
        """Analyze an observation for curiosity-triggering elements."""
        signals = []
        
        # Novelty-based curiosity
        novelty_score = self._calculate_novelty_score(observation)
        if novelty_score > self.novelty_threshold:
            signal = CuriositySignal(
                curiosity_type=CuriosityType.NOVELTY_SEEKING,
                target=observation.get("target", "unknown"),
                motivation_strength=novelty_score * self.curiosity_weights[CuriosityType.NOVELTY_SEEKING],
                novelty_score=novelty_score,
                knowledge_gap_score=0.0,
                prediction_error=0.0,
                exploration_value=novelty_score,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        # Knowledge gap curiosity
        knowledge_gap_score = self._calculate_knowledge_gap_score(observation)
        if knowledge_gap_score > self.knowledge_gap_threshold:
            signal = CuriositySignal(
                curiosity_type=CuriosityType.KNOWLEDGE_GAP,
                target=observation.get("target", "unknown"),
                motivation_strength=knowledge_gap_score * self.curiosity_weights[CuriosityType.KNOWLEDGE_GAP],
                novelty_score=0.0,
                knowledge_gap_score=knowledge_gap_score,
                prediction_error=0.0,
                exploration_value=knowledge_gap_score,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        # Prediction error curiosity
        prediction_error = self._calculate_prediction_error(observation)
        if prediction_error > self.prediction_error_threshold:
            signal = CuriositySignal(
                curiosity_type=CuriosityType.PREDICTION_ERROR,
                target=observation.get("target", "unknown"),
                motivation_strength=prediction_error * self.curiosity_weights[CuriosityType.PREDICTION_ERROR],
                novelty_score=0.0,
                knowledge_gap_score=0.0,
                prediction_error=prediction_error,
                exploration_value=prediction_error,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        # Competence building curiosity
        competence_potential = self._calculate_competence_building_potential(observation)
        if competence_potential > 0.5:
            signal = CuriositySignal(
                curiosity_type=CuriosityType.COMPETENCE_BUILDING,
                target=observation.get("target", "unknown"),
                motivation_strength=competence_potential * self.curiosity_weights[CuriosityType.COMPETENCE_BUILDING],
                novelty_score=0.0,
                knowledge_gap_score=0.0,
                prediction_error=0.0,
                exploration_value=competence_potential,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        return signals
    
    def _generate_intrinsic_curiosity(self, context: Dict[str, Any]) -> List[CuriositySignal]:
        """Generate intrinsic curiosity signals independent of external observations."""
        signals = []
        
        # Social curiosity - interest in other agents or humans
        if self._should_generate_social_curiosity():
            signal = CuriositySignal(
                curiosity_type=CuriosityType.SOCIAL_CURIOSITY,
                target="social_interaction",
                motivation_strength=0.6 * self.curiosity_weights[CuriosityType.SOCIAL_CURIOSITY],
                novelty_score=0.0,
                knowledge_gap_score=0.0,
                prediction_error=0.0,
                exploration_value=0.6,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        # Creative exploration curiosity
        if self._should_generate_creative_curiosity():
            signal = CuriositySignal(
                curiosity_type=CuriosityType.CREATIVE_EXPLORATION,
                target="creative_expression",
                motivation_strength=0.7 * self.curiosity_weights[CuriosityType.CREATIVE_EXPLORATION],
                novelty_score=0.0,
                knowledge_gap_score=0.0,
                prediction_error=0.0,
                exploration_value=0.7,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        # Random exploration for serendipitous discovery
        if random.random() < 0.1:  # 10% chance of random curiosity
            random_targets = ["environment", "knowledge", "skills", "relationships", "creativity"]
            target = random.choice(random_targets)
            
            signal = CuriositySignal(
                curiosity_type=CuriosityType.NOVELTY_SEEKING,
                target=target,
                motivation_strength=0.4,
                novelty_score=0.4,
                knowledge_gap_score=0.0,
                prediction_error=0.0,
                exploration_value=0.4,
                timestamp=time.time(),
                context=context
            )
            signals.append(signal)
        
        return signals
    
    def _calculate_novelty_score(self, observation: Dict[str, Any]) -> float:
        """Calculate novelty score for an observation."""
        observation_str = str(observation)
        
        # Compare with recent observations
        recent_observations = self._get_recent_observations(hours=24)
        
        if not recent_observations:
            return 1.0  # Everything is novel if no history
        
        # Calculate similarity with recent observations
        max_similarity = 0.0
        for recent_obs in recent_observations:
            similarity = self._calculate_observation_similarity(observation_str, str(recent_obs))
            max_similarity = max(max_similarity, similarity)
        
        # Novelty is inverse of maximum similarity
        novelty_score = 1.0 - max_similarity
        return max(0.0, min(1.0, novelty_score))
    
    def _calculate_knowledge_gap_score(self, observation: Dict[str, Any]) -> float:
        """Calculate knowledge gap score for an observation."""
        target = observation.get("target", "unknown")
        
        # Check current knowledge level about the target
        current_knowledge = self.knowledge_map.get(target, {})
        knowledge_completeness = len(current_knowledge) / 10.0  # Assume 10 is complete knowledge
        
        # Knowledge gap is inverse of completeness
        knowledge_gap = 1.0 - min(1.0, knowledge_completeness)
        
        # Adjust based on observation complexity
        complexity = self._estimate_observation_complexity(observation)
        adjusted_gap = knowledge_gap * complexity
        
        return max(0.0, min(1.0, adjusted_gap))
    
    def _calculate_prediction_error(self, observation: Dict[str, Any]) -> float:
        """Calculate prediction error for an observation."""
        target = observation.get("target", "unknown")
        
        # Get prediction model for this target
        prediction_model = self.prediction_models.get(target, {})
        
        if not prediction_model:
            return 0.5  # Moderate error if no model exists
        
        # Calculate prediction vs actual (simplified)
        predicted_outcome = prediction_model.get("predicted_outcome", 0.5)
        actual_outcome = observation.get("outcome", 0.5)
        
        prediction_error = abs(predicted_outcome - actual_outcome)
        return min(1.0, prediction_error)
    
    def _calculate_competence_building_potential(self, observation: Dict[str, Any]) -> float:
        """Calculate potential for competence building from an observation."""
        target = observation.get("target", "unknown")
        
        # Get current competence level
        current_competence = self.competence_levels.get(target, 0.0)
        
        # Estimate learning potential
        observation_complexity = self._estimate_observation_complexity(observation)
        learning_potential = observation_complexity * (1.0 - current_competence)
        
        return max(0.0, min(1.0, learning_potential))
    
    def _estimate_observation_complexity(self, observation: Dict[str, Any]) -> float:
        """Estimate the complexity of an observation."""
        # Simple complexity estimation based on content size and structure
        content_size = len(str(observation))
        structure_complexity = len(observation) if isinstance(observation, dict) else 1
        
        # Normalize to 0-1 range
        complexity = min(1.0, (content_size / 1000.0) + (structure_complexity / 20.0))
        return complexity
    
    def _should_generate_social_curiosity(self) -> bool:
        """Determine if social curiosity should be generated."""
        # Check if we haven't had social interaction recently
        recent_social_interactions = self._get_recent_social_interactions(hours=6)
        return len(recent_social_interactions) < 2
    
    def _should_generate_creative_curiosity(self) -> bool:
        """Determine if creative curiosity should be generated."""
        # Check if we haven't engaged in creative activities recently
        recent_creative_activities = self._get_recent_creative_activities(hours=12)
        return len(recent_creative_activities) < 1
    
    def _filter_and_prioritize_signals(self, signals: List[CuriositySignal]) -> List[CuriositySignal]:
        """Filter and prioritize curiosity signals."""
        if not signals:
            return []
        
        # Remove duplicate targets
        unique_signals = {}
        for signal in signals:
            key = f"{signal.curiosity_type.value}_{signal.target}"
            if key not in unique_signals or signal.motivation_strength > unique_signals[key].motivation_strength:
                unique_signals[key] = signal
        
        # Sort by motivation strength
        sorted_signals = sorted(unique_signals.values(), key=lambda s: s.motivation_strength, reverse=True)
        
        # Return top signals (limit to prevent overwhelming)
        return sorted_signals[:10]
    
    def _decay_curiosity_signals(self) -> None:
        """Apply decay to active curiosity signals."""
        current_time = time.time()
        
        # Decay signals based on age
        for signal in self.active_curiosity_signals:
            age_hours = (current_time - signal.timestamp) / 3600
            decay_factor = self.exploration_decay_rate ** age_hours
            signal.motivation_strength *= decay_factor
        
        # Remove signals below threshold
        self.active_curiosity_signals = [
            signal for signal in self.active_curiosity_signals
            if signal.motivation_strength > 0.1
        ]
    
    def _calculate_current_curiosity_level(self) -> float:
        """Calculate current overall curiosity level."""
        if not self.active_curiosity_signals:
            return self.base_curiosity_level
        
        # Average motivation strength of active signals
        total_motivation = sum(signal.motivation_strength for signal in self.active_curiosity_signals)
        average_motivation = total_motivation / len(self.active_curiosity_signals)
        
        # Combine with base curiosity level
        current_level = (self.base_curiosity_level + average_motivation) / 2
        return min(1.0, max(0.0, current_level))
    
    def _get_top_curiosity_targets(self) -> List[Dict[str, Any]]:
        """Get top curiosity targets with their motivation strengths."""
        target_strengths = defaultdict(float)
        
        for signal in self.active_curiosity_signals:
            target_strengths[signal.target] += signal.motivation_strength
        
        # Sort by total motivation strength
        sorted_targets = sorted(target_strengths.items(), key=lambda x: x[1], reverse=True)
        
        return [
            {"target": target, "motivation_strength": strength}
            for target, strength in sorted_targets[:5]
        ]
    
    def _create_exploration_goals(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Create exploration goals based on curiosity signals."""
        curiosity_signals = message.get("curiosity_signals", self.active_curiosity_signals)
        max_goals = message.get("max_goals", 3)
        
        new_exploration_goals = []
        
        # Group signals by target for goal creation
        target_signals = defaultdict(list)
        for signal in curiosity_signals:
            target_signals[signal.target].append(signal)
        
        # Create goals for top targets
        sorted_targets = sorted(
            target_signals.items(),
            key=lambda x: sum(s.motivation_strength for s in x[1]),
            reverse=True
        )
        
        for target, signals in sorted_targets[:max_goals]:
            goal = self._create_exploration_goal(target, signals)
            new_exploration_goals.append(goal)
            self.active_exploration_goals.append(goal)
        
        return {
            "new_exploration_goals": len(new_exploration_goals),
            "total_active_goals": len(self.active_exploration_goals),
            "exploration_goals": [goal.__dict__ for goal in new_exploration_goals],
            "goal_priorities": [goal.priority for goal in new_exploration_goals]
        }
    
    def _create_exploration_goal(self, target: str, signals: List[CuriositySignal]) -> ExplorationGoal:
        """Create an exploration goal for a specific target."""
        # Determine exploration strategy
        strategy = self._select_exploration_strategy(target, signals)
        
        # Calculate expected learning
        expected_learning = self._estimate_expected_learning(target, signals)
        
        # Determine resource requirements
        resource_requirements = self._estimate_resource_requirements(target, strategy)
        
        # Define success criteria
        success_criteria = self._define_success_criteria(target, signals)
        
        # Calculate priority
        priority = sum(signal.motivation_strength for signal in signals) / len(signals)
        
        goal = ExplorationGoal(
            goal_id=f"explore_{target}_{int(time())}",
            goal_type="exploration",
            target=target,
            exploration_strategy=strategy,
            curiosity_signals=signals,
            expected_learning=expected_learning,
            resource_requirements=resource_requirements,
            success_criteria=success_criteria,
            priority=priority,
            created_timestamp=time()
        )
        
        return goal
    
    def _select_exploration_strategy(self, target: str, signals: List[CuriositySignal]) -> ExplorationStrategy:
        """Select appropriate exploration strategy for a target."""
        # Analyze signal types to determine best strategy
        signal_types = [signal.curiosity_type for signal in signals]
        
        if CuriosityType.SOCIAL_CURIOSITY in signal_types:
            return ExplorationStrategy.SOCIAL_EXPLORATION
        elif CuriosityType.CREATIVE_EXPLORATION in signal_types:
            return ExplorationStrategy.CREATIVE_EXPLORATION
        elif CuriosityType.KNOWLEDGE_GAP in signal_types:
            return ExplorationStrategy.SYSTEMATIC_EXPLORATION
        elif CuriosityType.NOVELTY_SEEKING in signal_types:
            return ExplorationStrategy.DIRECTED_EXPLORATION
        else:
            return ExplorationStrategy.RANDOM_EXPLORATION
    
    def _estimate_expected_learning(self, target: str, signals: List[CuriositySignal]) -> Dict[str, float]:
        """Estimate expected learning outcomes from exploration."""
        return {
            "knowledge_gain": sum(s.knowledge_gap_score for s in signals) / len(signals),
            "skill_development": sum(s.exploration_value for s in signals) / len(signals),
            "competence_increase": self._estimate_competence_increase(target),
            "novelty_discovery": sum(s.novelty_score for s in signals) / len(signals)
        }
    
    def _estimate_competence_increase(self, target: str) -> float:
        """Estimate potential competence increase for a target."""
        current_competence = self.competence_levels.get(target, 0.0)
        # Potential increase is higher when current competence is lower
        potential_increase = (1.0 - current_competence) * 0.3
        return min(0.5, potential_increase)
    
    def _estimate_resource_requirements(self, target: str, strategy: ExplorationStrategy) -> Dict[str, Any]:
        """Estimate resource requirements for exploration."""
        base_requirements = {
            "time_estimate": 30,  # minutes
            "cognitive_load": 0.5,
            "social_interaction": False,
            "external_resources": []
        }
        
        # Adjust based on strategy
        if strategy == ExplorationStrategy.SOCIAL_EXPLORATION:
            base_requirements["social_interaction"] = True
            base_requirements["time_estimate"] = 60
        elif strategy == ExplorationStrategy.SYSTEMATIC_EXPLORATION:
            base_requirements["time_estimate"] = 90
            base_requirements["cognitive_load"] = 0.8
        elif strategy == ExplorationStrategy.CREATIVE_EXPLORATION:
            base_requirements["time_estimate"] = 45
            base_requirements["cognitive_load"] = 0.7
        
        return base_requirements
    
    def _define_success_criteria(self, target: str, signals: List[CuriositySignal]) -> Dict[str, Any]:
        """Define success criteria for exploration goal."""
        return {
            "minimum_knowledge_gain": 0.3,
            "minimum_novelty_discovery": 0.2,
            "minimum_satisfaction": 0.6,
            "maximum_time_limit": 120,  # minutes
            "specific_outcomes": self._define_specific_outcomes(target, signals)
        }
    
    def _define_specific_outcomes(self, target: str, signals: List[CuriositySignal]) -> List[str]:
        """Define specific outcomes expected from exploration."""
        outcomes = []
        
        for signal in signals:
            if signal.curiosity_type == CuriosityType.KNOWLEDGE_GAP:
                outcomes.append(f"Fill knowledge gap about {target}")
            elif signal.curiosity_type == CuriosityType.NOVELTY_SEEKING:
                outcomes.append(f"Discover novel aspects of {target}")
            elif signal.curiosity_type == CuriosityType.COMPETENCE_BUILDING:
                outcomes.append(f"Improve competence in {target}")
            elif signal.curiosity_type == CuriosityType.SOCIAL_CURIOSITY:
                outcomes.append(f"Understand social aspects of {target}")
            elif signal.curiosity_type == CuriosityType.CREATIVE_EXPLORATION:
                outcomes.append(f"Explore creative possibilities with {target}")
        
        return outcomes
    
    def _store_curiosity_signal(self, signal: CuriositySignal) -> None:
        """Store curiosity signal in memory."""
        signal_data = {
            "curiosity_type": signal.curiosity_type.value,
            "target": signal.target,
            "motivation_strength": signal.motivation_strength,
            "novelty_score": signal.novelty_score,
            "knowledge_gap_score": signal.knowledge_gap_score,
            "prediction_error": signal.prediction_error,
            "exploration_value": signal.exploration_value,
            "timestamp": signal.timestamp,
            "context": signal.context
        }
        
        self.memory.store(
            f"curiosity_signal_{int(signal.timestamp)}_{signal.target}",
            signal_data,
            ttl=86400 * 7  # Keep for 1 week
        )
    
    def _assess_curiosity_emotional_impact(self, result: Dict[str, Any]) -> Dict[str, float]:
        """Assess emotional impact of curiosity activities."""
        curiosity_level = self._calculate_current_curiosity_level()
        satisfaction_score = self.curiosity_satisfaction_score
        
        emotional_state = {}
        
        # Excitement based on curiosity level
        emotional_state["excitement"] = min(1.0, curiosity_level * 1.2)
        
        # Anticipation based on active exploration goals
        active_goals = len(self.active_exploration_goals)
        emotional_state["anticipation"] = min(1.0, active_goals * 0.3)
        
        # Satisfaction based on recent learning outcomes
        emotional_state["satisfaction"] = satisfaction_score
        
        # Wonder based on novelty discovery
        recent_novelty = self._calculate_recent_novelty_discovery()
        emotional_state["wonder"] = min(1.0, recent_novelty)
        
        return emotional_state
    
    def _calculate_recent_novelty_discovery(self) -> float:
        """Calculate recent novelty discovery score."""
        recent_outcomes = [outcome for outcome in self.learning_outcomes 
                          if time() - float(outcome.exploration_goal_id.split('_')[-1]) < 86400]  # Last 24 hours
        
        if not recent_outcomes:
            return 0.3  # Default moderate wonder
        
        average_novelty = sum(outcome.novelty_discovered for outcome in recent_outcomes) / len(recent_outcomes)
        return average_novelty
    
    # Helper methods for data retrieval
    def _get_recent_observations(self, hours: int = 24) -> List[Dict[str, Any]]:
        """Get recent observations from memory."""
        # This would interface with memory system
        return []
    
    def _get_recent_social_interactions(self, hours: int = 6) -> List[Dict[str, Any]]:
        """Get recent social interactions."""
        # This would interface with social interaction tracking
        return []
    
    def _get_recent_creative_activities(self, hours: int = 12) -> List[Dict[str, Any]]:
        """Get recent creative activities."""
        # This would interface with activity tracking
        return []
    
    def _calculate_observation_similarity(self, obs1: str, obs2: str) -> float:
        """Calculate similarity between two observations."""
        # Simple word-based similarity
        words1 = set(obs1.lower().split())
        words2 = set(obs2.lower().split())
        
        if not words1 and not words2:
            return 1.0
        if not words1 or not words2:
            return 0.0
        
        intersection = words1.intersection(words2)
        union = words1.union(words2)
        
        return len(intersection) / len(union)
    
    # Additional operation handlers
    def _evaluate_novelty(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Evaluate novelty of a specific observation."""
        observation = message.get("observation", {})
        novelty_score = self._calculate_novelty_score(observation)
        
        return {
            "novelty_score": novelty_score,
            "is_novel": novelty_score > self.novelty_threshold,
            "novelty_threshold": self.novelty_threshold
        }
    
    def _assess_knowledge_gaps(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Assess knowledge gaps in specified domains."""
        domains = message.get("domains", list(self.knowledge_map.keys()))
        
        knowledge_gaps = {}
        for domain in domains:
            current_knowledge = self.knowledge_map.get(domain, {})
            completeness = len(current_knowledge) / 10.0  # Assume 10 is complete
            gap_score = 1.0 - min(1.0, completeness)
            knowledge_gaps[domain] = gap_score
        
        return {
            "knowledge_gaps": knowledge_gaps,
            "top_gaps": sorted(knowledge_gaps.items(), key=lambda x: x[1], reverse=True)[:5]
        }
    
    def _update_learning_outcome(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Update learning outcome from completed exploration."""
        outcome_data = message.get("learning_outcome", {})
        
        outcome = LearningOutcome(
            exploration_goal_id=outcome_data.get("exploration_goal_id", "unknown"),
            knowledge_gained=outcome_data.get("knowledge_gained", {}),
            skills_developed=outcome_data.get("skills_developed", []),
            novelty_discovered=outcome_data.get("novelty_discovered", 0.0),
            prediction_accuracy_improvement=outcome_data.get("prediction_accuracy_improvement", 0.0),
            competence_increase=outcome_data.get("competence_increase", 0.0),
            surprise_level=outcome_data.get("surprise_level", 0.0),
            satisfaction_score=outcome_data.get("satisfaction_score", 0.5)
        )
        
        self.learning_outcomes.append(outcome)
        self.satisfaction_history.append(outcome.satisfaction_score)
        
        # Update curiosity satisfaction score
        if self.satisfaction_history:
            self.curiosity_satisfaction_score = sum(self.satisfaction_history) / len(self.satisfaction_history)
        
        # Update knowledge map and competence levels
        self._update_knowledge_and_competence(outcome)
        
        return {
            "learning_outcome_recorded": True,
            "satisfaction_score": outcome.satisfaction_score,
            "overall_satisfaction": self.curiosity_satisfaction_score,
            "knowledge_updated": len(outcome.knowledge_gained),
            "skills_developed": len(outcome.skills_developed)
        }
    
    def _update_knowledge_and_competence(self, outcome: LearningOutcome) -> None:
        """Update knowledge map and competence levels based on learning outcome."""
        # Update knowledge map
        for domain, knowledge in outcome.knowledge_gained.items():
            self.knowledge_map[domain].update(knowledge)
        
        # Update competence levels
        for skill in outcome.skills_developed:
            self.competence_levels[skill] += outcome.competence_increase
            self.competence_levels[skill] = min(1.0, self.competence_levels[skill])
    
    def _get_curiosity_state(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Get current curiosity engine state."""
        return {
            "base_curiosity_level": self.base_curiosity_level,
            "current_curiosity_level": self._calculate_current_curiosity_level(),
            "active_curiosity_signals": len(self.active_curiosity_signals),
            "active_exploration_goals": len(self.active_exploration_goals),
            "completed_exploration_goals": len(self.completed_exploration_goals),
            "curiosity_satisfaction_score": self.curiosity_satisfaction_score,
            "knowledge_domains": len(self.knowledge_map),
            "competence_areas": len(self.competence_levels),
            "recent_learning_outcomes": len([o for o in self.learning_outcomes 
                                           if time() - float(o.exploration_goal_id.split('_')[-1]) < 86400])
        }
    
    def _adjust_curiosity_parameters(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Adjust curiosity engine parameters."""
        adjustments = message.get("adjustments", {})
        
        if "base_curiosity_level" in adjustments:
            self.base_curiosity_level = max(0.0, min(1.0, adjustments["base_curiosity_level"]))
        
        if "novelty_threshold" in adjustments:
            self.novelty_threshold = max(0.0, min(1.0, adjustments["novelty_threshold"]))
        
        if "knowledge_gap_threshold" in adjustments:
            self.knowledge_gap_threshold = max(0.0, min(1.0, adjustments["knowledge_gap_threshold"]))
        
        if "prediction_error_threshold" in adjustments:
            self.prediction_error_threshold = max(0.0, min(1.0, adjustments["prediction_error_threshold"]))
        
        return {
            "parameters_adjusted": len(adjustments),
            "current_parameters": {
                "base_curiosity_level": self.base_curiosity_level,
                "novelty_threshold": self.novelty_threshold,
                "knowledge_gap_threshold": self.knowledge_gap_threshold,
                "prediction_error_threshold": self.prediction_error_threshold
            }
        } 