<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' http: https: data: blob: 'unsafe-inline'; connect-src 'self' ws: wss: http: https:; script-src 'self' 'unsafe-inline' 'unsafe-eval';">
    <title>NIS Protocol - VibeVoice Modern Chat</title>
    
    <!-- NIS State Management System -->
    <script src="/static/js/nis-state-client.js"></script>
    
    <!-- Markdown Support - Simple inline parser (no external CDN needed) -->
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0A0A0B;
            color: white;
            overflow-x: hidden;
            height: 100vh;
        }

        .chat-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
            position: relative;
            overflow: hidden;
        }

        /* Animated Background */
        .bg-gradient {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .bg-orb {
            position: absolute;
            border-radius: 50%;
            filter: blur(128px);
            mix-blend-mode: normal;
            animation: pulse 4s ease-in-out infinite;
        }

        .bg-orb:nth-child(1) {
            top: 0;
            left: 25%;
            width: 384px;
            height: 384px;
            background: rgba(139, 92, 246, 0.1);
            animation-delay: 0s;
        }

        .bg-orb:nth-child(2) {
            bottom: 0;
            right: 25%;
            width: 384px;
            height: 384px;
            background: rgba(99, 102, 241, 0.1);
            animation-delay: 0.7s;
        }

        .bg-orb:nth-child(3) {
            top: 25%;
            right: 33%;
            width: 256px;
            height: 256px;
            background: rgba(217, 70, 239, 0.1);
            filter: blur(96px);
            animation-delay: 1s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .main-content {
            width: 100%;
            max-width: 640px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 48px;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.6s ease-out forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            text-align: center;
            animation: fadeInUp 0.5s ease-out 0.2s both;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 500;
            letter-spacing: -0.025em;
            background: linear-gradient(to right, rgba(255,255,255,0.9), rgba(255,255,255,0.4));
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
            margin-bottom: 8px;
        }

        .header-line {
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(255,255,255,0.2), transparent);
            width: 0;
            margin: 0 auto 12px;
            animation: expandLine 0.8s ease-out 0.5s both;
        }

        @keyframes expandLine {
            to { width: 100%; }
        }

        .header p {
            font-size: 0.875rem;
            color: rgba(255,255,255,0.4);
            opacity: 0;
            animation: fadeIn 0.5s ease-out 0.3s both;
        }

        .chat-toggle-container {
            margin-top: 16px;
            opacity: 0;
            animation: fadeIn 0.5s ease-out 0.4s both;
        }

        .classic-chat-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            color: rgba(255,255,255,0.7);
            text-decoration: none;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .classic-chat-link:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.2);
            color: rgba(255,255,255,0.9);
            transform: translateY(-1px);
        }

        .classic-chat-link span {
            font-size: 0.9rem;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Chat Box */
        .chat-box {
            backdrop-filter: blur(32px);
            background: rgba(255,255,255,0.02);
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.05);
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.3);
            position: relative;
            transform: scale(0.98);
            animation: scaleIn 0.5s ease-out 0.1s both;
        }

        @keyframes scaleIn {
            to { transform: scale(1); }
        }

        /* Command Palette */
        .command-palette {
            position: absolute;
            left: 16px;
            right: 16px;
            bottom: 100%;
            margin-bottom: 8px;
            backdrop-filter: blur(24px);
            background: rgba(0,0,0,0.9);
            border-radius: 8px;
            z-index: 50;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            display: none;
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.15s ease-out;
        }

        .command-palette.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .command-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            cursor: pointer;
            color: rgba(255,255,255,0.7);
        }

        .command-item:hover,
        .command-item.active {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .command-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.6);
        }

        .command-prefix {
            color: rgba(255,255,255,0.4);
            font-size: 0.75rem;
            margin-left: 4px;
        }

        /* Text Area */
        .input-container {
            padding: 16px;
        }

        .chat-textarea {
            width: 100%;
            min-height: 60px;
            max-height: 200px;
            padding: 12px 16px;
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.9);
            font-size: 0.875rem;
            resize: none;
            outline: none;
            font-family: inherit;
            line-height: 1.5;
        }

        .chat-textarea::placeholder {
            color: rgba(255,255,255,0.2);
        }

        .textarea-ring {
            position: absolute;
            inset: 0;
            border-radius: 8px;
            pointer-events: none;
            border: 2px solid rgba(139, 92, 246, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .chat-textarea:focus + .textarea-ring {
            opacity: 1;
        }

        /* Attachments */
        .attachments {
            padding: 0 16px 12px;
            display: none;
            flex-wrap: wrap;
            gap: 8px;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .attachments.show {
            display: flex;
            opacity: 1;
            max-height: 200px;
        }

        .attachment {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.03);
            padding: 6px 12px;
            border-radius: 8px;
            color: rgba(255,255,255,0.7);
            animation: fadeInScale 0.3s ease;
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .attachment-remove {
            color: rgba(255,255,255,0.4);
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .attachment-remove:hover {
            color: white;
        }

        /* Controls */
        .chat-controls {
            padding: 16px;
            border-top: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .control-buttons {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-btn {
            padding: 8px;
            color: rgba(255,255,255,0.4);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .control-btn:hover {
            color: rgba(255,255,255,0.9);
            background: rgba(255,255,255,0.05);
        }

        .control-btn.active {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.9);
        }

        /* Modern AI Voice Input Component */
        .ai-voice-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px;
            min-width: 200px;
        }

        /* 🎨 AMAZING VOICE VISUALIZER - GPT + GROK + APPLE HYBRID */
        .voice-visualizer-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 320px;
            height: 320px;
            display: none;
            z-index: 9999;
            pointer-events: none;
        }

        .voice-visualizer-container.active {
            display: block;
        }

        #voiceVisualizerCanvas {
            width: 100%;
            height: 100%;
            filter: blur(0.5px);
        }

        .visualizer-glow {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, transparent 70%);
            filter: blur(40px);
            animation: glow-pulse 3s ease-in-out infinite;
        }

        @keyframes glow-pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }

        .voice-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: rgba(20, 20, 30, 0.8);
            backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .voice-button::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 50%;
            padding: 3px;
            background: linear-gradient(135deg, 
                rgba(59, 130, 246, 0.8),
                rgba(147, 51, 234, 0.8),
                rgba(236, 72, 153, 0.8),
                rgba(251, 146, 60, 0.8)
            );
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask-composite: exclude;
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .voice-button:hover::before {
            opacity: 0.6;
            animation: edge-glow 3s linear infinite;
        }

        .voice-button.listening::before,
        .voice-button.recording::before,
        .voice-button.processing::before,
        .voice-button.playing::before {
            opacity: 1;
            animation: edge-glow 3s linear infinite;
        }

        @keyframes edge-glow {
            0% { 
                background: linear-gradient(0deg, 
                    rgba(59, 130, 246, 0.9),
                    rgba(147, 51, 234, 0.9),
                    rgba(236, 72, 153, 0.9),
                    rgba(251, 146, 60, 0.9)
                );
            }
            25% { 
                background: linear-gradient(90deg, 
                    rgba(59, 130, 246, 0.9),
                    rgba(147, 51, 234, 0.9),
                    rgba(236, 72, 153, 0.9),
                    rgba(251, 146, 60, 0.9)
                );
            }
            50% { 
                background: linear-gradient(180deg, 
                    rgba(59, 130, 246, 0.9),
                    rgba(147, 51, 234, 0.9),
                    rgba(236, 72, 153, 0.9),
                    rgba(251, 146, 60, 0.9)
                );
            }
            75% { 
                background: linear-gradient(270deg, 
                    rgba(59, 130, 246, 0.9),
                    rgba(147, 51, 234, 0.9),
                    rgba(236, 72, 153, 0.9),
                    rgba(251, 146, 60, 0.9)
                );
            }
            100% { 
                background: linear-gradient(360deg, 
                    rgba(59, 130, 246, 0.9),
                    rgba(147, 51, 234, 0.9),
                    rgba(236, 72, 153, 0.9),
                    rgba(251, 146, 60, 0.9)
                );
            }
        }

        .voice-button:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.4);
        }

        .voice-button.recording {
            background: rgba(220, 38, 38, 0.2);
            box-shadow: 0 0 40px rgba(220, 38, 38, 0.6);
            animation: pulse-scale 1s ease-in-out infinite;
        }
        
        .voice-button.listening {
            background: rgba(34, 197, 94, 0.2);
            box-shadow: 0 0 40px rgba(34, 197, 94, 0.6);
            animation: pulse-scale 2s ease-in-out infinite;
        }
        
        .voice-button.processing {
            background: rgba(251, 146, 60, 0.2);
            box-shadow: 0 0 40px rgba(251, 146, 60, 0.6);
            animation: pulse-scale 1.5s ease-in-out infinite;
        }
        
        .voice-button.playing {
            background: rgba(147, 51, 234, 0.2);
            box-shadow: 0 0 40px rgba(147, 51, 234, 0.6);
            animation: pulse-scale 1s ease-in-out infinite;
        }

        @keyframes pulse-scale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }
        
        @keyframes pulse-red {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(220, 38, 38, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(220, 38, 38, 0.8); }
        }
        
        @keyframes pulse-green {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(22, 163, 74, 0.4); }
            50% { transform: scale(1.02); box-shadow: 0 0 25px rgba(22, 163, 74, 0.6); }
        }
        
        @keyframes pulse-yellow {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(245, 158, 11, 0.4); }
            50% { transform: scale(1.03); box-shadow: 0 0 25px rgba(245, 158, 11, 0.6); }
        }
        
        @keyframes pulse-purple {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(139, 92, 246, 0.4); }
            50% { transform: scale(1.03); box-shadow: 0 0 25px rgba(139, 92, 246, 0.6); }
        }
        
        .voice-status {
            font-size: 0.875rem;
            margin-top: 0.5rem;
            opacity: 0.8;
            transition: all 0.3s ease;
        }
        
        .voice-status.success { color: #16a34a; }
        .voice-status.error { color: #dc2626; }
        .voice-status.warning { color: #f59e0b; }
        .voice-status.info { color: #3b82f6; }
        .voice-status.listening { color: #16a34a; }
        .voice-status.recording { color: #dc2626; }
        .voice-status.processing { color: #f59e0b; }
        .voice-status.playing { color: #8b5cf6; }

        .mic-icon {
            color: rgba(255,255,255,0.7);
            transition: all 0.3s ease;
        }

        .voice-button.recording .mic-icon {
            display: none;
        }

        .recording-spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: rgba(255,255,255,0.8);
            animation: spin 3s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .voice-timer {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            transition: opacity 0.3s ease;
        }

        .voice-timer.recording {
            color: rgba(255,255,255,0.9);
        }

        .voice-visualizer {
            height: 16px;
            width: 256px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .visualizer-bar {
            width: 2px;
            border-radius: 1px;
            background: rgba(255,255,255,0.1);
            height: 4px;
            transition: all 0.3s ease;
        }

        .visualizer-bar.active {
            background: rgba(255,255,255,0.5);
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            0% { height: 4px; }
            100% { height: 16px; }
        }

        .voice-status {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            margin: 0;
            height: 16px;
        }

        .voice-status.recording {
            color: rgba(255,255,255,0.9);
        }

        /* Multi-Agent UI Enhancements */
        .agent-indicator {
            position: fixed;
            top: 140px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 200px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .agent-indicator.consciousness {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.9), rgba(79, 70, 229, 0.9));
            color: white;
        }

        .agent-indicator.physics {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9));
            color: white;
        }

        .agent-indicator.coordination {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.9));
            color: white;
        }

        .agent-indicator.research {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(217, 119, 6, 0.9));
            color: white;
        }

        .agent-indicator.memory {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.9), rgba(219, 39, 119, 0.9));
            color: white;
        }

        .agent-indicator.default {
            background: linear-gradient(135deg, rgba(107, 114, 128, 0.9), rgba(75, 85, 99, 0.9));
            color: white;
        }

        .agent-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .agent-handoff {
            position: fixed;
            top: 180px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 12px;
            z-index: 999;
            animation: slideIn 0.5s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(100%); }
            to { opacity: 1; transform: translateX(0); }
        }

        .handoff-arrow {
            animation: pulse 1s infinite;
        }

        .agent-thinking {
            position: fixed;
            top: 220px;
            right: 20px;
            padding: 6px 12px;
            border-radius: 15px;
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            font-size: 11px;
            z-index: 998;
            border: 1px solid rgba(59, 130, 246, 0.2);
            animation: thinking 2s infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Agent-specific message styling */
        .message.agent-consciousness {
            border-left: 4px solid #9333ea;
        }

        .message.agent-physics {
            border-left: 4px solid #10b981;
        }

        .message.agent-coordination {
            border-left: 4px solid #3b82f6;
        }

        .message.agent-research {
            border-left: 4px solid #f59e0b;
        }

        .message.agent-memory {
            border-left: 4px solid #ec4899;
        }

        .agent-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-right: 8px;
            text-transform: uppercase;
        }

        .agent-badge.consciousness {
            background: rgba(147, 51, 234, 0.2);
            color: #9333ea;
        }

        .agent-badge.physics {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .agent-badge.coordination {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .agent-badge.research {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .agent-badge.memory {
            background: rgba(236, 72, 153, 0.2);
            color: #ec4899;
        }

        .send-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .send-btn:disabled {
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.4);
            cursor: not-allowed;
        }

        .send-btn:not(:disabled) {
            background: white;
            color: #0A0A0B;
            box-shadow: 0 4px 8px rgba(255,255,255,0.1);
        }

        .send-btn:not(:disabled):hover {
            transform: scale(1.01);
        }

        .send-btn:not(:disabled):active {
            transform: scale(0.98);
        }

        /* Command Suggestions */
        .command-suggestions {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 8px;
            animation: fadeInUp 0.5s ease-out;
        }

        .suggestion-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 8px;
            font-size: 0.875rem;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            opacity: 0;
            transform: translateY(10px);
            animation: fadeInUp 0.5s ease-out forwards;
        }

        .suggestion-btn:nth-child(1) { animation-delay: 0s; }
        .suggestion-btn:nth-child(2) { animation-delay: 0.1s; }
        .suggestion-btn:nth-child(3) { animation-delay: 0.2s; }
        .suggestion-btn:nth-child(4) { animation-delay: 0.3s; }

        .suggestion-btn:hover {
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.9);
            transform: translateY(-2px);
        }

        /* Typing Indicator */
        .typing-indicator {
            position: fixed;
            bottom: 32px;
            left: 50%;
            transform: translateX(-50%);
            backdrop-filter: blur(32px);
            background: rgba(255,255,255,0.02);
            border-radius: 9999px;
            padding: 8px 16px;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.05);
            display: none;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
            transition: all 0.3s ease;
        }

        .typing-indicator.show {
            display: flex;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .typing-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 500;
            color: rgba(255,255,255,0.9);
        }

        .typing-text {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            color: rgba(255,255,255,0.7);
        }

        .typing-dots {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .typing-dot {
            width: 6px;
            height: 6px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255,255,255,0.3);
            animation: typingDot 1.2s ease-in-out infinite;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.15s; }
        .typing-dot:nth-child(3) { animation-delay: 0.3s; }

        @keyframes typingDot {
            0%, 60%, 100% {
                opacity: 0.3;
                transform: scale(0.85);
            }
            30% {
                opacity: 0.9;
                transform: scale(1.1);
            }
        }

        /* Focus glow effect */
        .focus-glow {
            position: fixed;
            width: 800px;
            height: 800px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.02;
            background: linear-gradient(to right, rgb(139, 92, 246), rgb(217, 70, 239), rgb(99, 102, 241));
            filter: blur(96px);
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            display: none;
        }

        .focus-glow.active {
            display: block;
        }

        /* Chat Messages Area */
        .chat-messages {
            flex: 1;
            max-height: 400px;
            overflow-y: auto;
            padding: 16px;
            margin-bottom: 16px;
            display: none;
        }

        .chat-messages.show {
            display: block;
        }

        /* Terminal Integration */
        .terminal-section {
            border-top: 1px solid rgba(255,255,255,0.05);
            background: rgba(0,0,0,0.3);
            border-radius: 0 0 16px 16px;
            display: none;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .terminal-section.show {
            display: block;
            opacity: 1;
            max-height: 300px;
        }

        .terminal-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.2);
        }

        .terminal-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.875rem;
            color: rgba(255,255,255,0.7);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
        }

        .terminal-controls {
            display: flex;
            gap: 8px;
        }

        .terminal-btn {
            padding: 4px 8px;
            font-size: 0.75rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .terminal-btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .terminal-output {
            padding: 16px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            color: rgba(255,255,255,0.8);
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.4);
        }

        .terminal-input-container {
            padding: 12px 16px;
            background: rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .terminal-prompt {
            color: rgba(99, 102, 241, 0.8);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.75rem;
        }

        .terminal-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.75rem;
            outline: none;
        }

        .terminal-input::placeholder {
            color: rgba(255,255,255,0.3);
        }

        /* Code Block Styling */
        .code-block {
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            font-size: 0.75rem;
            line-height: 1.4;
            position: relative;
        }

        .code-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .code-language {
            color: rgba(99, 102, 241, 0.8);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .code-actions {
            display: flex;
            gap: 4px;
        }

        .code-action-btn {
            padding: 2px 6px;
            font-size: 0.6rem;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 3px;
            color: rgba(255,255,255,0.6);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .code-action-btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .message {
            margin-bottom: 16px;
            animation: messageSlideIn 0.3s ease;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-user {
            text-align: right;
        }

        .message-bubble {
            display: inline-block;
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 16px;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        .message-user .message-bubble {
            background: rgba(139, 92, 246, 0.2);
            color: white;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .message-assistant {
            text-align: left;
        }

        .message-assistant .message-bubble {
            background: rgba(255,255,255,0.05);
            color: rgba(255,255,255,0.9);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .message-time {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.4);
            margin-top: 4px;
        }

        /* Scrollbar Styling */
        .chat-messages::-webkit-scrollbar {
            width: 4px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
        }

        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }

        /* LangChain Agent UI Styles */
        .tool-call {
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .tool-header {
            padding: 12px 16px;
            background: rgba(59, 130, 246, 0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .tool-header:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .tool-icon {
            font-size: 16px;
        }

        .tool-name {
            font-weight: 600;
            font-size: 14px;
            flex: 1;
        }

        .tool-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 500;
        }

        .tool-status.running {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
        }

        .tool-status.completed {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .tool-status.error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .tool-content {
            padding: 16px;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 13px;
            background: rgba(0,0,0,0.3);
            display: none;
        }

        .tool-content.expanded {
            display: block;
        }

        .tool-args, .tool-result {
            margin-bottom: 12px;
        }

        .tool-result {
            padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .reasoning-step {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            margin: 8px 0;
            padding: 16px;
        }

        .step-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .step-number {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .step-title {
            font-weight: 600;
            font-size: 14px;
            color: #a78bfa;
        }

        .step-content {
            font-size: 14px;
            line-height: 1.5;
            color: rgba(255,255,255,0.9);
        }

        .artifact-container {
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .artifact-header {
            padding: 12px 16px;
            background: rgba(16, 185, 129, 0.1);
            border-bottom: 1px solid rgba(16, 185, 129, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .artifact-icon {
            font-size: 16px;
        }

        .artifact-title {
            font-weight: 600;
            font-size: 14px;
            color: #10b981;
            flex: 1;
        }

        .artifact-action {
            padding: 4px 12px;
            background: rgba(16, 185, 129, 0.2);
            border: none;
            border-radius: 6px;
            color: #10b981;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .artifact-action:hover {
            background: rgba(16, 185, 129, 0.3);
        }

        .artifact-preview {
            padding: 16px;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Agent Workflow Visualization */
        .agent-workflow {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 16px;
            margin: 16px 0;
        }

        .workflow-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
        }

        .workflow-steps {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .workflow-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            font-size: 14px;
        }

        .workflow-step.active {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .workflow-step.completed {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .step-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .step-icon.active {
            background: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        .step-icon.completed {
            background: rgba(16, 185, 129, 0.3);
            color: #10b981;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .chat-container {
                padding: 16px;
            }
            
            .main-content {
                gap: 32px;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .command-suggestions {
                flex-direction: column;
            }
        }

        /* ⚙️ Voice Settings Panel Styles */
        .voice-settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.98), rgba(40, 40, 70, 0.98));
            border: 1px solid rgba(138, 118, 255, 0.3);
            border-radius: 16px;
            padding: 24px;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(138, 118, 255, 0.2);
            z-index: 10000;
            backdrop-filter: blur(20px);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(138, 118, 255, 0.2);
            padding-bottom: 12px;
        }

        .settings-header h3 {
            margin: 0;
            color: #8a76ff;
            font-size: 1.3rem;
        }

        .close-settings-btn {
            background: none;
            border: none;
            color: #999;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            line-height: 32px;
            text-align: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .close-settings-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-group label {
            color: #aaa;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .setting-select {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(138, 118, 255, 0.3);
            border-radius: 8px;
            padding: 10px 12px;
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .setting-select:hover {
            border-color: rgba(138, 118, 255, 0.5);
            background: rgba(138, 118, 255, 0.1);
        }

        .setting-select:focus {
            outline: none;
            border-color: #8a76ff;
            box-shadow: 0 0 0 3px rgba(138, 118, 255, 0.2);
        }

        .setting-hint {
            color: #777;
            font-size: 0.8rem;
            margin: 0;
            font-style: italic;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
        }

        .preset-btn {
            flex: 1;
            background: rgba(138, 118, 255, 0.15);
            border: 1px solid rgba(138, 118, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .preset-btn:hover {
            background: rgba(138, 118, 255, 0.3);
            border-color: #8a76ff;
            transform: translateY(-2px);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        .apply-settings-btn {
            background: linear-gradient(135deg, #8a76ff, #6b5bd8);
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            color: #fff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 8px;
        }

        .apply-settings-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(138, 118, 255, 0.4);
        }

        .apply-settings-btn:active {
            transform: translateY(0);
        }

        /* 🛑 Voice Stop Button */
        .voice-stop-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000) !important;
            animation: pulse-stop 2s ease-in-out infinite;
        }

        @keyframes pulse-stop {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(255, 68, 68, 0);
            }
        }

        .voice-stop-btn:hover {
            background: linear-gradient(135deg, #ff6666, #ee2222) !important;
            transform: translateY(-2px);
        }

        /* 🔊 Audio Control Bar */
        .audio-control-bar {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.98), rgba(30, 41, 59, 0.98));
            padding: 12px 24px;
            border-radius: 24px;
            display: none;
            gap: 12px;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(59, 130, 246, 0.3);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(59, 130, 246, 0.4);
            z-index: 10001;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translate(-50%, 20px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .audio-control-bar.visible { display: flex; }

        .audio-control-btn {
            background: none;
            border: none;
            color: #38bdf8;
            font-size: 20px;
            cursor: pointer;
            padding: 8px;
            transition: all 0.2s;
            border-radius: 8px;
        }

        .audio-control-btn:hover {
            color: #7dd3fc;
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.1);
        }

        .audio-progress-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 200px;
        }

        .audio-time-display {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #94a3b8;
            font-family: monospace;
        }

        .audio-progress-bar {
            width: 200px;
            height: 6px;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 3px;
            cursor: pointer;
        }

        .audio-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #38bdf8, #7dd3fc);
            border-radius: 3px;
            transition: width 0.1s linear;
            position: relative;
        }

        .audio-progress-fill::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            background: rgba(59, 130, 246, 0.3);
            border-radius: 2px;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
        }

        .audio-now-playing {
            color: #94a3b8;
            font-size: 12px;
        }

        .audio-now-playing::before {
            content: '🎵';
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* ⚡ Quick Actions Panel */
        .quick-actions-panel {
            position: fixed;
            right: 24px;
            bottom: 100px;
            background: linear-gradient(135deg, rgba(30, 30, 50, 0.98), rgba(40, 40, 70, 0.98));
            border: 1px solid rgba(138, 118, 255, 0.4);
            border-radius: 16px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 20px rgba(138, 118, 255, 0.2);
            backdrop-filter: blur(20px);
            z-index: 9998;
            animation: slideInRight 0.3s ease-out;
            max-height: 80vh;
            overflow-y: auto;
        }

        @keyframes slideInRight {
            from { transform: translateX(120%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .quick-actions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 4px;
            border-bottom: 1px solid rgba(138, 118, 255, 0.2);
            margin-bottom: 8px;
        }

        .quick-actions-title {
            font-size: 13px;
            font-weight: 600;
            color: #a78bfa;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quick-action-toggle {
            background: none;
            border: none;
            color: #a78bfa;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            transition: all 0.2s;
            border-radius: 4px;
        }

        .quick-action-toggle:hover {
            background: rgba(167, 139, 250, 0.1);
            transform: rotate(90deg);
        }

        .quick-action-btn {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #e2e8f0;
            padding: 10px 14px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        .quick-action-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #38bdf8;
            transform: translateX(-4px);
            box-shadow: 4px 0 12px rgba(59, 130, 246, 0.3);
        }

        .quick-action-icon { font-size: 18px; min-width: 24px; text-align: center; }
        .quick-action-text { flex: 1; font-weight: 500; }
        .quick-action-badge {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
        }

        /* 🤖 Provider Selector */
        .provider-select {
            background: rgba(30, 30, 50, 0.8);
            border: 1px solid rgba(138, 118, 255, 0.3);
            color: #e2e8f0;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            outline: none;
        }

        .provider-select:hover {
            border-color: rgba(138, 118, 255, 0.5);
            background: rgba(40, 40, 60, 0.9);
        }

        .provider-select:focus {
            border-color: #8a76ff;
            box-shadow: 0 0 0 3px rgba(138, 118, 255, 0.1);
        }

        .provider-select option {
            background: #1a1a2e;
            color: #e2e8f0;
            padding: 8px;
        }
    </style>
</head>
<body>
    <!-- 🎨 AMAZING VOICE VISUALIZER -->
    <div class="voice-visualizer-container" id="voiceVisualizerContainer">
        <div class="visualizer-glow"></div>
        <canvas id="voiceVisualizerCanvas" width="640" height="640"></canvas>
    </div>

    <!-- ⚙️ VOICE SETTINGS PANEL -->
    <div id="voiceSettingsPanel" class="voice-settings-panel" style="display: none;">
        <div class="settings-header">
            <h3>🎤 Voice Settings</h3>
            <button class="close-settings-btn" id="closeVoiceSettings">×</button>
        </div>
        <div class="settings-content">
            <!-- TTS Engine Selection -->
            <div class="setting-group">
                <label>🔊 Voice Engine</label>
                <select id="ttsEngineSelect" class="setting-select">
                    <option value="gtts" selected>Google TTS (Fast) - ~200ms</option>
                    <option value="bark">Bark TTS (Natural) - ~1.5s</option>
                    <option value="vibevoice">🎙️ VibeVoice (AI Agents) - ~1s</option>
                </select>
                <p class="setting-hint">Fast for quick responses, Natural for quality, AI Agents for personality</p>
            </div>

            <!-- Voice Selection (changes based on engine) -->
            <div class="setting-group">
                <label id="voiceSelectLabel">🗣️ Voice</label>
                <select id="voiceSelect" class="setting-select">
                    <!-- Options populated by JavaScript -->
                </select>
                <p class="setting-hint" id="voiceHint">Select your preferred voice</p>
            </div>

            <!-- Whisper Model Selection -->
            <div class="setting-group">
                <label>🎙️ Speech Recognition</label>
                <select id="whisperModelSelect" class="setting-select">
                    <option value="tiny">Tiny (Very Fast)</option>
                    <option value="base" selected>Base (Balanced)</option>
                    <option value="small">Small (Accurate)</option>
                    <option value="medium">Medium (Best Quality)</option>
                </select>
                <p class="setting-hint">Higher quality = slower processing</p>
            </div>

            <!-- Quick Presets -->
            <div class="setting-group">
                <label>⚡ Quick Presets</label>
                <div class="preset-buttons">
                    <button class="preset-btn" data-preset="fastest">⚡ Fastest</button>
                    <button class="preset-btn" data-preset="balanced">⚖️ Balanced</button>
                    <button class="preset-btn" data-preset="quality">🎯 Best Quality</button>
                </div>
            </div>

            <!-- Apply Button -->
            <button class="apply-settings-btn" id="applyVoiceSettings">
                ✅ Apply Settings
            </button>
        </div>
    </div>

    <!-- 🔊 AUDIO CONTROL BAR -->
    <div id="audioControlBar" class="audio-control-bar">
        <div class="audio-now-playing">Now Playing</div>
        <button id="audioPauseBtn" class="audio-control-btn" title="Pause/Resume">
            ⏸️
        </button>
        <button id="audioStopBtn" class="audio-control-btn" title="Stop">
            ⏹️
        </button>
        <div class="audio-progress-container">
            <div class="audio-time-display">
                <span id="audioCurrentTime">0:00</span>
                <span id="audioDuration">0:00</span>
            </div>
            <div class="audio-progress-bar" id="audioProgressBar">
                <div class="audio-progress-fill" id="audioProgressFill" style="width: 0%"></div>
            </div>
        </div>
        <div class="volume-control">
            <span style="font-size: 16px;">🔊</span>
            <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="100">
        </div>
    </div>

    <!-- ⚡ QUICK ACTIONS PANEL -->
    <div id="quickActionsPanel" class="quick-actions-panel">
        <div class="quick-actions-header">
            <div class="quick-actions-title">
                <span>⚡</span>
                <span>Quick Actions</span>
            </div>
            <button id="quickActionsToggle" class="quick-action-toggle" title="Minimize">−</button>
        </div>
        <div class="quick-actions-content">
            <button class="quick-action-btn" onclick="window.clearChat()">
                <span class="quick-action-icon">🗑️</span>
                <span class="quick-action-text">Clear Chat</span>
            </button>
            <button class="quick-action-btn" onclick="window.exportChat()">
                <span class="quick-action-icon">💾</span>
                <span class="quick-action-text">Export Chat</span>
            </button>
            <button class="quick-action-btn" onclick="window.runCodeDemo()">
                <span class="quick-action-icon">💻</span>
                <span class="quick-action-text">Code Execution</span>
                <span class="quick-action-badge">NEW</span>
            </button>
            <button class="quick-action-btn" onclick="window.runPhysicsDemo()">
                <span class="quick-action-icon">🔬</span>
                <span class="quick-action-text">Physics Demo</span>
                <span class="quick-action-badge">PINN</span>
            </button>
            <button class="quick-action-btn" onclick="window.runDeepResearch()">
                <span class="quick-action-icon">📚</span>
                <span class="quick-action-text">Deep Research</span>
            </button>
            <button class="quick-action-btn" onclick="window.showKeyboardShortcuts()">
                <span class="quick-action-icon">⌨️</span>
                <span class="quick-action-text">Shortcuts</span>
            </button>
        </div>
    </div>

    <!-- ⚡ QUICK ACTIONS FAB (Floating Action Button) -->
    <button id="quickActionsFab" class="quick-actions-fab" title="Quick Actions">
        ⚡
    </button>

    <div class="chat-container">
        <!-- Animated Background -->
        <div class="bg-gradient">
            <div class="bg-orb"></div>
            <div class="bg-orb"></div>
            <div class="bg-orb"></div>
        </div>

        <!-- Focus Glow Effect -->
        <div class="focus-glow" id="focusGlow"></div>

        <div class="main-content">
            <!-- Header -->
            <div class="header">
                <h1>🤖 NIS Protocol AI Assistant <span class="dev-badge" style="font-size: 14px; background-color: #2a2a2a; color: #3b82f6; padding: 4px 8px; border-radius: 4px; margin-left: 10px;">DEV MODE</span></h1>
                <div class="header-line"></div>
                <p>Intelligent system analysis and real-time insights • 🎙️ VibeVoice Multi-Speaker TTS</p>
                <div class="chat-toggle-container">
                    <a href="/console" class="classic-chat-link">
                        <span>🔄</span>
                        Switch to Classic Chat
                    </a>
                    <button id="toggleDevTools" style="margin-left: 12px; background-color: #2a2a2a; color: #3b82f6; border: 1px solid #374151; border-radius: 4px; padding: 4px 8px; cursor: pointer;">
                        <span>🛠️</span>
                        Dev Tools
                    </button>
                </div>
            </div>
            
            <!-- Development Tools Panel -->
            <div id="devToolsPanel" style="display: none; position: absolute; top: 120px; right: 20px; width: 400px; background-color: #1a1a1a; border: 1px solid #374151; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; padding: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; border-bottom: 1px solid #374151; padding-bottom: 8px;">
                    <h3 style="margin: 0; color: #3b82f6;">🛠️ Development Tools</h3>
                    <button id="closeDevTools" style="background: none; border: none; color: #a0a0a0; font-size: 20px; cursor: pointer;">×</button>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #a0a0a0;">Endpoint Testing</h4>
                    <div style="display: flex; gap: 8px;">
                        <select id="endpointSelect" style="flex: 1; background-color: #2a2a2a; color: white; border: 1px solid #374151; border-radius: 4px; padding: 6px;">
                            <option value="/chat">Standard Chat</option>
                            <option value="/chat/stream" selected>Streaming Chat</option>
                            <option value="/chat/formatted">Formatted Chat</option>
                        </select>
                        <button id="testEndpoint" style="background-color: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer;">Test</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #a0a0a0;">Response Debug</h4>
                    <div style="display: flex; gap: 16px;">
                        <label style="display: flex; align-items: center; gap: 4px; color: white;">
                            <input type="checkbox" id="showRawResponse"> Show Raw JSON
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; color: white;">
                            <input type="checkbox" id="showTimings"> Show Timings
                        </label>
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #a0a0a0;">WebSocket Testing</h4>
                    <div style="display: flex; gap: 8px;">
                        <button id="testWebSocket" style="background-color: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer;">Test Connection</button>
                        <button id="sendTestEvent" style="background-color: #3b82f6; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer;">Send Test Event</button>
                    </div>
                    <div id="wsStatus" style="margin-top: 8px; color: #a0a0a0;">WebSocket: Unknown</div>
                    <button id="testAudio" style="background-color: #10b981; color: white; border: none; border-radius: 4px; padding: 6px 12px; cursor: pointer; margin-top: 8px;">Test Audio</button>
                </div>
                
                <div>
                    <h4 style="margin: 0 0 8px 0; color: #a0a0a0;">Network Monitor</h4>
                    <div id="networkLog" style="max-height: 150px; overflow-y: auto; background-color: #2a2a2a; border-radius: 4px; padding: 8px; font-family: monospace; font-size: 12px; color: #a0a0a0;">
                        <div>No requests logged yet</div>
                    </div>
                    <button id="clearNetworkLog" style="margin-top: 8px; background-color: #2a2a2a; color: white; border: 1px solid #374151; border-radius: 4px; padding: 4px 8px; cursor: pointer; width: 100%;">Clear Log</button>
                </div>
            </div>

            <!-- Chat Box -->
            <div class="chat-box">
                <!-- Command Palette -->
                <div class="command-palette" id="commandPalette">
                    <div class="command-item" data-prefix="/clone" data-label="Clone UI">
                        <div class="command-icon">🖼️</div>
                        <div>Clone UI</div>
                        <div class="command-prefix">/clone</div>
                    </div>
                    <div class="command-item" data-prefix="/figma" data-label="Import Figma">
                        <div class="command-icon">🎨</div>
                        <div>Import Figma</div>
                        <div class="command-prefix">/figma</div>
                    </div>
                    <div class="command-item" data-prefix="/page" data-label="Create Page">
                        <div class="command-icon">📄</div>
                        <div>Create Page</div>
                        <div class="command-prefix">/page</div>
                    </div>
                    <div class="command-item" data-prefix="/improve" data-label="Improve">
                        <div class="command-icon">✨</div>
                        <div>Improve</div>
                        <div class="command-prefix">/improve</div>
                    </div>
                    <div class="command-item" data-prefix="/run" data-label="Run Code">
                        <div class="command-icon">🔧</div>
                        <div>Run Code</div>
                        <div class="command-prefix">/run</div>
                    </div>
                    <div class="command-item" data-prefix="/python" data-label="Python Script">
                        <div class="command-icon">🐍</div>
                        <div>Python Script</div>
                        <div class="command-prefix">/python</div>
                    </div>
                    <div class="command-item" data-prefix="/terminal" data-label="Terminal">
                        <div class="command-icon">💻</div>
                        <div>Terminal</div>
                        <div class="command-prefix">/terminal</div>
                    </div>
                    <div class="command-item" data-prefix="/file" data-label="File Operations">
                        <div class="command-icon">📁</div>
                        <div>File Operations</div>
                        <div class="command-prefix">/file</div>
                    </div>
                </div>

                <!-- Chat Messages -->
                <div class="chat-messages" id="chatMessages"></div>

                <!-- Input Container -->
                <div class="input-container">
                    <div style="position: relative;">
                        <textarea 
                            id="chatInput" 
                            class="chat-textarea" 
                            placeholder="Ask the NIS Protocol AI Assistant..."
                            rows="1"
                        ></textarea>
                        <div class="textarea-ring"></div>
                    </div>
                </div>

                <!-- Attachments -->
                <div class="attachments" id="attachments"></div>

                <!-- Controls -->
                <div class="chat-controls">
                    <div class="control-buttons">
                        <button class="control-btn" id="attachBtn" title="Attach file">
                            📎
                        </button>
                        <!-- Modern AI Voice Input Component -->
                        <div class="ai-voice-input" id="aiVoiceInput">
                            <button class="voice-button" id="voiceButton" type="button">
                                <div class="mic-icon" id="micIcon">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/>
                                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                                        <line x1="12" y1="19" x2="12" y2="23"/>
                                        <line x1="8" y1="23" x2="16" y2="23"/>
                                    </svg>
                                </div>
                                <div class="recording-spinner" id="recordingSpinner" style="display: none;">
                                    <div class="spinner"></div>
                                </div>
                            </button>
                            <span class="voice-timer" id="voiceTimer">00:00</span>
                            <div class="voice-status" id="voiceStatus">Voice chat ready</div>
                            <div class="voice-visualizer" id="voiceVisualizer">
                                <!-- Visualizer bars will be generated by JS -->
                            </div>
                        </div>
                        <button class="control-btn" id="voiceSettingsBtn" title="Voice Settings">
                            🎛️
                        </button>
                        <button class="control-btn voice-stop-btn" id="voiceStopBtn" title="Stop Voice Chat" style="display: none;">
                            🛑
                        </button>
                        <button class="control-btn" id="commandBtn" title="Commands">
                            ⌘
                        </button>
                        <button class="control-btn" id="runnerBtn" title="Runner Terminal">
                            🔧
                        </button>
                    </div>
                    
                    <!-- Provider Selector -->
                    <div class="provider-selector" style="display: flex; flex-direction: column; gap: 4px; min-width: 200px;">
                        <select id="provider" class="provider-select" onchange="updateProviderSelection()">
                            <option value="">🤖 Auto-Select Provider</option>
                            <option value="smart">🧠 Smart Consensus</option>
                            <option value="openai">🧠 OpenAI (GPT-4o)</option>
                            <option value="anthropic">🎭 Claude 4 Sonnet</option>
                            <option value="deepseek">🔬 DeepSeek R1</option>
                            <option value="google">🌟 Gemini 2.5 Flash</option>
                            <option value="kimi">🌙 Kimi K2 (Long Context)</option>
                            <option value="bitnet">⚡ BitNet (Local)</option>
                        </select>
                        <div id="provider-indicator" style="
                            font-size: 10px; 
                            color: #94a3b8; 
                            margin-top: 2px;
                            min-height: 14px;
                            text-align: center;
                        "></div>
                    </div>
                    
                    <button class="send-btn" id="sendBtn">
                        <span id="sendIcon">📤</span>
                        <span>Send</span>
                    </button>
                    <button class="control-btn" id="terminalBtn" title="Terminal">
                        💻
                    </button>
                </div>
            </div>

            <!-- Terminal Section -->
            <div class="terminal-section" id="terminalSection">
                <div class="terminal-header">
                    <div class="terminal-title">
                        <span>🔧</span>
                        <span>NIS Runner Terminal</span>
                    </div>
                    <div class="terminal-controls">
                        <button class="terminal-btn" id="clearTerminal">Clear</button>
                        <button class="terminal-btn" id="closeTerminal">Close</button>
                    </div>
                </div>
                <div class="terminal-output" id="terminalOutput">
                    <div style="color: rgba(99, 102, 241, 0.8);">NIS Protocol Runner v1.0.0</div>
                    <div style="color: rgba(255,255,255,0.6);">Secure execution environment ready.</div>
                    <div style="color: rgba(255,255,255,0.4);">Type 'help' for available commands.</div>
                </div>
                <div class="terminal-input-container">
                    <span class="terminal-prompt">runner $</span>
                    <input type="text" class="terminal-input" id="terminalInput" placeholder="Enter command...">
                </div>
            </div>
        </div>

            <!-- Command Suggestions -->
            <div class="command-suggestions">
                <button class="suggestion-btn" data-command="/run">
                    <span>🔧</span>
                    <span>Run Code</span>
                </button>
                <button class="suggestion-btn" data-command="/python">
                    <span>🐍</span>
                    <span>Python Script</span>
                </button>
                <button class="suggestion-btn" data-command="/terminal">
                    <span>💻</span>
                    <span>Terminal</span>
                </button>
                <button class="suggestion-btn" data-command="/file">
                    <span>📁</span>
                    <span>File Ops</span>
                </button>
                <button class="suggestion-btn" data-command="/voice">
                    <span>🎙️</span>
                    <span>VibeVoice TTS</span>
                </button>
                <button class="suggestion-btn" data-command="/dialogue">
                    <span>🗣️</span>
                    <span>Agent Dialogue</span>
                </button>
                <button class="suggestion-btn" data-command="/stream">
                    <span>🔊</span>
                    <span>Real-time Stream</span>
                </button>
            </div>
        </div>

        <!-- Typing Indicator -->
        <div class="typing-indicator" id="typingIndicator">
            <div class="typing-avatar">AI</div>
            <div class="typing-text">
                <span>Thinking</span>
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 🎨 NIS Protocol Modern Chat - v3.3.0-voice-settings-complete
        // Cache version: 2025-10-04-02:00 - Voice Settings & Enhanced Debugging
        // 🆕 Voice Settings Panel with TTS/Voice/Whisper selection
        // 🆕 Quick presets (Fastest/Balanced/Best Quality)
        // 🆕 Dedicated STOP button to exit voice mode
        // 🆕 Visualizer and stop button show/hide properly
        // 🆕 Enhanced audio debugging with detailed logs
        // ✅ Fixed CSP error, AudioContext close error, manual recording
        // ✅ Clear user instructions
        
        // Global state
        let attachments = [];
        let activeSuggestion = -1;
        let isTyping = false;
        let currentController = null;

        // DOM elements - will be initialized when DOM is ready
        let chatInput, sendBtn, attachBtn, commandBtn, commandPalette, attachmentsContainer, typingIndicator, focusGlow, chatMessages, sendIcon;

        // Add message to chat (defined early for use in event listeners)
        function addMessage(content, isUser = false, type = 'normal') {
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                messagesContainer.classList.add('show');
                
                const message = document.createElement('div');
                message.className = `message ${isUser ? 'message-user' : 'message-assistant'}`;
                if (type === 'system') {
                    message.className = 'message message-system';
                }
                
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble';
                
                // Use markdown rendering for assistant messages
                if (!isUser && typeof marked !== 'undefined') {
                    try {
                        bubble.innerHTML = marked.parse(content);
                    } catch (e) {
                bubble.textContent = content;
                    }
                } else {
                    bubble.textContent = content;
                }
                
                const time = document.createElement('div');
                time.className = 'message-time';
                time.textContent = new Date().toLocaleTimeString();
                
                message.appendChild(bubble);
                message.appendChild(time);
                messagesContainer.appendChild(message);
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        // 🎤 Voice Settings Global State
        let voiceSettings = {
            engine: 'gtts',
            voice: 'en',
            whisperModel: 'base',
            speed: 1.0,
            volume: 1.0
        };

        let availableVoiceSettings = null;

        // 🎤 Load Voice Settings from Backend
        async function loadVoiceSettings() {
            try {
                const response = await fetch('/voice/settings');
                const data = await response.json();
                availableVoiceSettings = data;
                
                // Populate voice options based on current engine
                updateVoiceOptions(voiceSettings.engine);
                
                console.log('✅ Voice settings loaded:', data);
            } catch (error) {
                console.error('❌ Failed to load voice settings:', error);
                addMessage('⚠️ Could not load voice settings from backend', false, 'system');
            }
        }

        // 🎤 Update Voice Options Based on Engine
        function updateVoiceOptions(engine) {
            if (!availableVoiceSettings) return;
            
            const voiceSelect = document.getElementById('voiceSelect');
            const voiceHint = document.getElementById('voiceHint');
            
            if (!voiceSelect) return;
            
            voiceSelect.innerHTML = '';
            
            const engineData = availableVoiceSettings.tts_engines.find(e => e.id === engine);
            if (!engineData) return;
            
            engineData.voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.id;
                option.textContent = voice.name;
                if (voice.description) {
                    option.title = voice.description;
                }
                voiceSelect.appendChild(option);
            });
            
            // Update hint
            if (voiceHint) {
                voiceHint.textContent = `${engineData.voices.length} voices available for ${engineData.name}`;
            }
            
            // Select current voice if available
            if (voiceSettings.voice) {
                voiceSelect.value = voiceSettings.voice;
            }
        }

        // 🎤 Apply Preset Configuration
        function applyPreset(presetName) {
            if (!availableVoiceSettings || !availableVoiceSettings.recommendations) return;
            
            const preset = availableVoiceSettings.recommendations[presetName];
            if (!preset) return;
            
            // Update UI
            const ttsEngineSelect = document.getElementById('ttsEngineSelect');
            const voiceSelect = document.getElementById('voiceSelect');
            const whisperModelSelect = document.getElementById('whisperModelSelect');
            
            if (ttsEngineSelect) {
                ttsEngineSelect.value = preset.engine;
                updateVoiceOptions(preset.engine);
            }
            
            if (voiceSelect) {
                voiceSelect.value = preset.voice;
            }
            
            if (whisperModelSelect) {
                whisperModelSelect.value = preset.whisper;
            }
            
            console.log(`✅ Applied preset: ${presetName}`, preset);
            addMessage(`⚡ Applied ${presetName} preset`, false, 'system');
        }

        // 🎤 Apply Current Settings
        function applySettings() {
            const ttsEngineSelect = document.getElementById('ttsEngineSelect');
            const voiceSelect = document.getElementById('voiceSelect');
            const whisperModelSelect = document.getElementById('whisperModelSelect');
            
            if (ttsEngineSelect) voiceSettings.engine = ttsEngineSelect.value;
            if (voiceSelect) voiceSettings.voice = voiceSelect.value;
            if (whisperModelSelect) voiceSettings.whisperModel = whisperModelSelect.value;
            
            console.log('✅ Voice settings updated:', voiceSettings);
            
            // If voice mode is active, inform the user to restart for changes to take effect
            if (conversationalVoice && conversationalVoice.voiceEnabled) {
                addMessage('ℹ️ Settings will apply to your next voice session. Stop and restart voice chat to use the new settings.', false, 'system');
            }
        }

        // 🤖 Provider Selection Functions
        function getProviderDisplayInfo(provider) {
            const providerMap = {
                'openai': { name: 'OpenAI GPT-4o', icon: '🧠', color: '#10a37f' },
                'anthropic': { name: 'Claude 4 Sonnet', icon: '🎭', color: '#d4772d' },
                'deepseek': { name: 'DeepSeek R1', icon: '🔬', color: '#1e40af' },
                'google': { name: 'Gemini 2.5 Flash', icon: '🌟', color: '#4285f4' },
                'kimi': { name: 'Kimi K2', icon: '🌙', color: '#8b5cf6' },
                'bitnet': { name: 'BitNet Local', icon: '⚡', color: '#059669' },
                'smart': { name: 'Smart Consensus', icon: '🧠', color: '#7c3aed' },
                'auto': { name: 'Auto-Selected', icon: '🤖', color: '#6b7280' }
            };
            
            return providerMap[provider] || { 
                name: provider.toUpperCase(), 
                icon: '🤖', 
                color: '#6b7280' 
            };
        }

        function updateProviderSelection() {
            const providerSelect = document.getElementById('provider');
            const indicator = document.getElementById('provider-indicator');
            
            if (!providerSelect || !indicator) return;
            
            const provider = providerSelect.value || '';
            
            if (provider) {
                const providerInfo = getProviderDisplayInfo(provider);
                indicator.innerHTML = `Selected: <span style="color: ${providerInfo.color}; font-weight: 500;">${providerInfo.icon} ${providerInfo.name}</span>`;
            } else {
                indicator.innerHTML = 'Auto-select will choose the best provider for your request';
            }
        }

        // Initialize DOM elements when ready
        function initializeDOMElements() {
            chatInput = document.getElementById('chatInput');
            sendBtn = document.getElementById('sendBtn');
            attachBtn = document.getElementById('attachBtn');
            commandBtn = document.getElementById('commandBtn');
            commandPalette = document.getElementById('commandPalette');
            attachmentsContainer = document.getElementById('attachments');
            typingIndicator = document.getElementById('typingIndicator');
            focusGlow = document.getElementById('focusGlow');
            chatMessages = document.getElementById('chatMessages');
            sendIcon = document.getElementById('sendIcon');
            
            // Get additional button elements
            const runnerBtn = document.getElementById('runnerBtn');
            const terminalBtn = document.getElementById('terminalBtn');
            const terminalInput = document.getElementById('terminalInput');
            const clearTerminal = document.getElementById('clearTerminal');
            const closeTerminal = document.getElementById('closeTerminal');
            const voiceSettingsBtn = document.getElementById('voiceSettingsBtn');
            
            // Set up event listeners after DOM elements are found
            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
                // Enable send button initially if there's text
                sendBtn.disabled = false;
            }
            if (attachBtn) attachBtn.addEventListener('click', addAttachment);
            
            // Enable/disable send button based on input
            if (chatInput && sendBtn) {
                chatInput.addEventListener('input', () => {
                    const hasText = chatInput.value.trim().length > 0;
                    sendBtn.disabled = !hasText;
                    adjustTextareaHeight();
                });
            }
            
            // Command button
            if (commandBtn && chatInput && commandPalette) {
                commandBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (commandPalette.classList.contains('show')) {
                        hideCommandPalette();
                    } else {
                        chatInput.value = '/';
                        chatInput.focus();
                        showCommandPalette();
                    }
                });
            }
            
            // Runner button
            if (runnerBtn) {
                runnerBtn.addEventListener('click', () => {
                    addMessage(`🔧 **NIS Runner Terminal Ready!**

**📁 File Operations:**
• \`/files\` - List all files
• \`/read filename.txt\` - Read file content
• \`/mkdir dirname\` - Create directory
• \`/delete filename.txt\` - Delete file

**🐍 Python & Scripts:**
• \`/python print("hello")\` - Run Python code
• \`/script script.py\` - Execute Python script
• \`/install package\` - Install Python package

**🌐 Network & APIs:**
• \`/curl https://api.example.com\` - Make HTTP request
• \`/ping hostname\` - Network connectivity test
• \`/dns domain.com\` - DNS lookup

**🔧 System Commands:**
• \`/ps\` - List running processes
• \`/env\` - Show environment variables
• \`/help\` - Show this help message

Ready to execute your commands safely! 🚀`, false, 'system');
                });
            }
            
            // Terminal buttons
            if (terminalBtn) {
                terminalBtn.addEventListener('click', () => {
                    const terminalSection = document.getElementById('terminalSection');
                    const terminalInput = document.getElementById('terminalInput');
                    if (terminalSection) {
                        terminalSection.classList.toggle('show');
                        if (terminalSection.classList.contains('show') && terminalInput) {
                            terminalInput.focus();
                        }
                    }
                });
            }
            
            if (clearTerminal) {
                clearTerminal.addEventListener('click', () => {
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput) {
                        terminalOutput.innerHTML = `
                            <div style="color: rgba(99, 102, 241, 0.8);">NIS Protocol Runner v1.0.0</div>
                            <div style="color: rgba(255,255,255,0.6);">Secure execution environment ready.</div>
                            <div style="color: rgba(255,255,255,0.4);">Type 'help' for available commands.</div>
                        `;
                    }
                });
            }
            
            if (closeTerminal) {
                closeTerminal.addEventListener('click', () => {
                    const terminalSection = document.getElementById('terminalSection');
                    if (terminalSection) {
                        terminalSection.classList.remove('show');
                    }
                });
            }
            
            // Voice Settings Button
            if (voiceSettingsBtn) {
                voiceSettingsBtn.addEventListener('click', async () => {
                    const panel = document.getElementById('voiceSettingsPanel');
                    if (panel) {
                        panel.style.display = 'block';
                        // Load available voices from backend
                        await loadVoiceSettings();
                    }
                });
            }
            
            // Voice Stop Button
            const voiceStopBtn = document.getElementById('voiceStopBtn');
            if (voiceStopBtn) {
                voiceStopBtn.addEventListener('click', async () => {
                    console.log('🛑 STOP button clicked - Exiting voice chat');
                    if (conversationalVoice) {
                        await conversationalVoice.stopVoiceMode();
                        // Hide visualizer
                        const visualizerContainer = document.getElementById('voiceVisualizerContainer');
                        if (visualizerContainer) {
                            visualizerContainer.style.display = 'none';
                        }
                        // Hide stop button
                        voiceStopBtn.style.display = 'none';
                        // Return to regular chat
                        addMessage('✅ Voice chat stopped. You\'re back in regular chat mode.', false, 'system');
                    }
                });
            }
            
            // Close Voice Settings
            const closeVoiceSettings = document.getElementById('closeVoiceSettings');
            if (closeVoiceSettings) {
                closeVoiceSettings.addEventListener('click', () => {
                    const panel = document.getElementById('voiceSettingsPanel');
                    if (panel) {
                        panel.style.display = 'none';
                    }
                });
            }
            
            // Apply Voice Settings
            const applyVoiceSettings = document.getElementById('applyVoiceSettings');
            if (applyVoiceSettings) {
                applyVoiceSettings.addEventListener('click', () => {
                    applySettings();
                    const panel = document.getElementById('voiceSettingsPanel');
                    if (panel) {
                        panel.style.display = 'none';
                    }
                    addMessage('✅ Voice settings applied successfully!', false, 'system');
                });
            }
            
            // Preset Buttons
            const presetButtons = document.querySelectorAll('.preset-btn');
            presetButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const preset = btn.dataset.preset;
                    applyPreset(preset);
                });
            });
            
            // TTS Engine Change
            const ttsEngineSelect = document.getElementById('ttsEngineSelect');
            if (ttsEngineSelect) {
                ttsEngineSelect.addEventListener('change', () => {
                    updateVoiceOptions(ttsEngineSelect.value);
                });
            }
            
            // Terminal input event listener
            if (terminalInput) {
                terminalInput.addEventListener('keypress', async (e) => {
                    if (e.key === 'Enter') {
                        const command = terminalInput.value.trim();
                        if (!command) return;

                        // Add command to terminal output
                        const terminalOutput = document.getElementById('terminalOutput');
                        if (terminalOutput) {
                            const commandLine = document.createElement('div');
                            commandLine.innerHTML = `<span style="color: rgba(99, 102, 241, 0.8);">$</span> ${command}`;
                            terminalOutput.appendChild(commandLine);

                            // Clear input
                            terminalInput.value = '';

                            // Process command (simplified for now)
                            const resultLine = document.createElement('div');
                            resultLine.style.color = 'rgba(255,255,255,0.8)';
                            resultLine.textContent = `Command executed: ${command}`;
                            terminalOutput.appendChild(resultLine);

                            // Scroll to bottom
                            terminalOutput.scrollTop = terminalOutput.scrollHeight;
                        }
                    }
                });
            }
            
            // Set up chat input event listeners
            if (chatInput) {
                chatInput.addEventListener('focus', () => {
                    if (focusGlow) focusGlow.classList.add('active');
                });

                chatInput.addEventListener('blur', () => {
                    if (focusGlow) focusGlow.classList.remove('active');
                });

                chatInput.addEventListener('keydown', (e) => {
                    if (commandPalette && commandPalette.classList.contains('show')) {
                        try {
                            const items = commandPalette.querySelectorAll('.command-item');
                            
                            if (e.key === 'ArrowDown') {
                                e.preventDefault();
                                activeSuggestion = activeSuggestion < items.length - 1 ? activeSuggestion + 1 : 0;
                                updateActiveSuggestion();
                            } else if (e.key === 'ArrowUp') {
                                e.preventDefault();
                                activeSuggestion = activeSuggestion > 0 ? activeSuggestion - 1 : items.length - 1;
                                updateActiveSuggestion();
                            } else if (e.key === 'Tab' || e.key === 'Enter') {
                                e.preventDefault();
                                if (activeSuggestion >= 0) {
                                    const selectedItem = items[activeSuggestion];
                                    applyCommand(selectedItem.getAttribute('data-prefix'));
                                }
                            } else if (e.key === 'Escape') {
                                e.preventDefault();
                                hideCommandPalette();
                            }
                        } catch (error) {
                            console.warn('Error handling command palette navigation:', error);
                        }
                    } else if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendMessage();
                    }
                });
            }
            
            // Initialize provider selection indicator
            updateProviderSelection();
        }

        // Auto-resize textarea
        function adjustTextareaHeight() {
            if (chatInput) {
            chatInput.style.height = '60px';
            const newHeight = Math.max(60, Math.min(chatInput.scrollHeight, 200));
            chatInput.style.height = newHeight + 'px';
            }
        }

        // Update send button state
        function updateSendButton() {
            if (sendBtn && chatInput) {
                const hasText = chatInput.value.trim().length > 0;
                sendBtn.disabled = !hasText;
            }
        }

        // Show/hide command palette
        function showCommandPalette() {
            if (!commandPalette || !chatInput) return;
            commandPalette.classList.add('show');
            updateActiveSuggestion();
        }

        function hideCommandPalette() {
            if (!commandPalette) return;
            commandPalette.classList.remove('show');
            activeSuggestion = -1;
        }

        // Update active command suggestion
        function updateActiveSuggestion() {
            if (!commandPalette) return;
            try {
                const items = commandPalette.querySelectorAll('.command-item');
                if (items && items.length > 0) {
                    items.forEach((item, index) => {
                        if (item) item.classList.toggle('active', index === activeSuggestion);
                    });
                }
            } catch (error) {
                console.warn('Error updating active suggestion:', error);
            }
        }

        // Apply command from palette
        function applyCommand(prefix) {
            chatInput.value = prefix + ' ';
            hideCommandPalette();
            chatInput.focus();
            adjustTextareaHeight();
            updateSendButton();
        }

        // Update send button state
        function updateSendButton() {
            if (chatInput && sendBtn) {
            const hasText = chatInput.value.trim().length > 0;
            sendBtn.disabled = !hasText || isTyping;
            }
        }

        // Add attachment
        function addAttachment() {
            const fileName = `file-${Math.floor(Math.random() * 1000)}.pdf`;
            attachments.push(fileName);
            renderAttachments();
        }

        // Remove attachment
        function removeAttachment(index) {
            attachments.splice(index, 1);
            renderAttachments();
        }

        // Render attachments
        function renderAttachments() {
            attachmentsContainer.innerHTML = '';
            if (attachments.length > 0) {
                attachmentsContainer.classList.add('show');
                attachments.forEach((file, index) => {
                    const attachment = document.createElement('div');
                    attachment.className = 'attachment';
                    attachment.innerHTML = `
                        <span>${file}</span>
                        <span class="attachment-remove" onclick="removeAttachment(${index})">✕</span>
                    `;
                    attachmentsContainer.appendChild(attachment);
                });
            } else {
                attachmentsContainer.classList.remove('show');
            }
        }


        // Show typing indicator
        function showTyping() {
            isTyping = true;
            typingIndicator.classList.add('show');
            updateSendButton();
        }

        // Hide typing indicator
        function hideTyping() {
            isTyping = false;
            typingIndicator.classList.remove('show');
            updateSendButton();
        }

        // Execute runner command
        async function executeRunnerCommand(command) {
            try {
                const response = await fetch('/api/langgraph/invoke', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tool: "run_shell",
                        args: { cmd: command, timeout: 30 }
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    const output = result.stdout || 'Command executed successfully';
                    addMessage(`🔧 Runner: ${command}\n\`\`\`\n${output}\n\`\`\``, false);
                } else {
                    const error = result.error || result.stderr || 'Command failed';
                    addMessage(`❌ Runner Error: ${command}\n\`\`\`\n${error}\n\`\`\``, false);
                }
            } catch (error) {
                addMessage(`🚨 Runner Connection Error: ${error.message}`, false);
            }
        }

        // Execute Python script
        async function executePythonScript(filename, content) {
            try {
                // First, write the script
                await fetch('/tools/run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tool: "write_script",
                        args: { filename: filename, content: content }
                    })
                });

                // Then execute it
                const response = await fetch('/api/langgraph/invoke', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tool: "run_python",
                        args: { filepath: filename, timeout: 60 }
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    const output = result.stdout || 'Script executed successfully';
                    addMessage(`🐍 Python: ${filename}\n\`\`\`\n${output}\n\`\`\``, false);
                } else {
                    const error = result.error || result.stderr || 'Script failed';
                    addMessage(`❌ Python Error: ${filename}\n\`\`\`\n${error}\n\`\`\``, false);
                }
            } catch (error) {
                addMessage(`🚨 Python Execution Error: ${error.message}`, false);
            }
        }

        // LangChain Agent UI - Tool Call Visualization
        function createToolCallElement(toolCall) {
            const toolElement = document.createElement('div');
            toolElement.className = 'tool-call';
            toolElement.innerHTML = `
                <div class="tool-header">
                    <span class="tool-icon">🔧</span>
                    <span class="tool-name">${toolCall.name}</span>
                    <span class="tool-status ${toolCall.status || 'running'}">${toolCall.status || 'Running'}</span>
                </div>
                <div class="tool-content">
                    <div class="tool-args">
                        <strong>Arguments:</strong>
                        <pre>${JSON.stringify(toolCall.args || {}, null, 2)}</pre>
                    </div>
                    ${toolCall.result ? `
                        <div class="tool-result">
                            <strong>Result:</strong>
                            <pre>${JSON.stringify(toolCall.result, null, 2)}</pre>
                        </div>
                    ` : ''}
                </div>
            `;
            return toolElement;
        }

        // LangChain Agent UI - Reasoning Steps
        function createReasoningElement(step, index) {
            const stepElement = document.createElement('div');
            stepElement.className = 'reasoning-step';
            stepElement.innerHTML = `
                <div class="step-header">
                    <span class="step-number">${index + 1}</span>
                    <span class="step-title">${step.title || 'Reasoning Step'}</span>
                </div>
                <div class="step-content">${step.content || step}</div>
            `;
            return stepElement;
        }

        // LangChain Agent UI - Artifact Rendering
        function createArtifactElement(artifact) {
            const artifactElement = document.createElement('div');
            artifactElement.className = 'artifact-container';
            artifactElement.innerHTML = `
                <div class="artifact-header">
                    <span class="artifact-icon">📄</span>
                    <span class="artifact-title">${artifact.title || 'Artifact'}</span>
                    <button class="artifact-action" onclick="openArtifact('${artifact.id}')">View</button>
                </div>
                <div class="artifact-preview">
                    ${artifact.preview || artifact.content || 'No preview available'}
                </div>
            `;
            return artifactElement;
        }

        // Send message with streaming
        async function sendMessage() {
            if (!chatInput) return;
            const message = chatInput.value.trim();
            if (!message || isTyping) return;
            
            let assistantMessage = ''; // Declare at function scope for voice access

            // Check for runner commands
            if (message.startsWith('/run ')) {
                const command = message.substring(5);
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                await executeRunnerCommand(command);
                return;
            }

            if (message.startsWith('/python ')) {
                const code = message.substring(8);
                const filename = `script_${Date.now()}.py`;
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                await executePythonScript(filename, code);
                return;
            }

            // Voice command handler
            if (message === '/voice') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                
                if (conversationalVoice) {
                    await conversationalVoice.toggleVoiceMode();
                    const status = conversationalVoice.voiceEnabled ? 'enabled' : 'disabled';
                    addMessage(`🎙️ Conversational voice chat ${status}`, false, 'system');
                } else {
                    addMessage('❌ Voice chat not available', false, 'system');
                }
                return;
            }

            // File operations
            if (message === '/files') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('list_files', {});
                    const files = result.files || [];
                    const fileList = files.map(f => `${f.type === 'directory' ? '📁' : '📄'} ${f.name} (${f.size} bytes)`).join('\n');
                    addMessage(`📁 Workspace Files:\n\`\`\`\n${fileList || 'No files found'}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error: ${error.message}`, false);
                }
                return;
            }

            if (message.startsWith('/read ')) {
                const filename = message.substring(6);
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('read_file', { filepath: filename });
                    addMessage(`📄 File: ${filename}\n\`\`\`\n${result.content}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error reading file: ${error.message}`, false);
                }
                return;
            }

            if (message.startsWith('/mkdir ')) {
                const dirname = message.substring(7);
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('create_directory', { path: dirname });
                    addMessage(`✅ Directory created: ${result.path}`, false);
                } catch (error) {
                    addMessage(`❌ Error creating directory: ${error.message}`, false);
                }
                return;
            }

            if (message.startsWith('/delete ')) {
                const filename = message.substring(8);
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('delete_file', { filepath: filename });
                    addMessage(`🗑️ File deleted: ${result.deleted}`, false);
                } catch (error) {
                    addMessage(`❌ Error deleting file: ${error.message}`, false);
                }
                return;
            }

            // System info commands
            if (message === '/sysinfo') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('system_info', {});
                    const info = result.system_info;
                    addMessage(`💻 System Information:\n\`\`\`\nPlatform: ${info.platform}\nPython: ${info.python_version}\nCPU Cores: ${info.cpu_count}\nMemory: ${(info.memory_available / 1024 / 1024 / 1024).toFixed(2)} GB available\nDisk Usage: ${info.disk_usage}%\nWorkspace: ${info.workspace}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error getting system info: ${error.message}`, false);
                }
                return;
            }

            if (message === '/disk') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('disk_usage', {});
                    const disk = result.disk_usage;
                    addMessage(`💽 Disk Usage:\n\`\`\`\nTotal: ${(disk.total / 1024 / 1024 / 1024).toFixed(2)} GB\nUsed: ${(disk.used / 1024 / 1024 / 1024).toFixed(2)} GB\nFree: ${(disk.free / 1024 / 1024 / 1024).toFixed(2)} GB\nUsage: ${disk.percent_used.toFixed(1)}%\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error getting disk usage: ${error.message}`, false);
                }
                return;
            }

            if (message === '/processes') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('process_list', {});
                    const processes = result.processes.slice(0, 10);
                    const processList = processes.map(p => `${p.pid}: ${p.name} (${p.cpu_percent}% CPU)`).join('\n');
                    addMessage(`⚙️ Running Processes (Top 10):\n\`\`\`\n${processList}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error getting processes: ${error.message}`, false);
                }
                return;
            }

            // Advanced tools
            if (message === '/report') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('generate_report', {});
                    addMessage(`📊 System Report Generated:\n\`\`\`\nSaved to: ${result.saved_to}\nGenerated: ${result.report.generated_at}\nFiles in workspace: ${result.report.workspace_files.length}\nRecent executions: ${result.report.execution_log.length}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error generating report: ${error.message}`, false);
                }
                return;
            }

            if (message === '/backup') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('backup_workspace', {});
                    addMessage(`💾 Workspace Backup Created:\n\`\`\`\nFile: ${result.backup_file}\nSize: ${(result.size / 1024).toFixed(2)} KB\nCreated: ${result.created_at}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Error creating backup: ${error.message}`, false);
                }
                return;
            }

            if (message.startsWith('/network') || message === '/network') {
                const host = message.includes(' ') ? message.split(' ')[1] : 'google.com';
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('network_test', { host: host });
                    addMessage(`🌐 Network Test (${result.host}):\n\`\`\`\nStatus: ${result.response_time}\nConnectivity: ${result.success ? '✅ Online' : '❌ Offline'}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Network test error: ${error.message}`, false);
                }
                return;
            }

            if (message === '/git') {
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('git_status', {});
                    if (result.is_git_repo) {
                        addMessage(`🔄 Git Status:\n\`\`\`\n${result.clean ? 'Working directory clean' : result.status}\n\`\`\``, false);
                    } else {
                        addMessage(`📁 Not a git repository`, false);
                    }
                } catch (error) {
                    addMessage(`❌ Git error: ${error.message}`, false);
                }
                return;
            }

            if (message.startsWith('/install ')) {
                const package = message.substring(9);
                addMessage(message, true);
                chatInput.value = '';
                adjustTextareaHeight();
                updateSendButton();
                try {
                    const result = await executeRunnerTool('install_package', { package: package });
                    addMessage(`📦 Package Installation:\n\`\`\`\nPackage: ${result.package}\nStatus: ${result.success ? '✅ Installed' : '❌ Failed'}\n${result.output || result.error}\n\`\`\``, false);
                } catch (error) {
                    addMessage(`❌ Installation error: ${error.message}`, false);
                }
                return;
            }

            // Add user message
            addMessage(message, true);
            
            // Clear input
            chatInput.value = '';
            attachments = [];
            renderAttachments();
            adjustTextareaHeight();
            updateSendButton();

            // Show typing indicator
            showTyping();
            sendIcon.textContent = '⏳';

            // Cancel any existing stream
            if (currentController) {
                currentController.abort();
            }

            currentController = new AbortController();

            try {
                // Get selected provider
                const providerSelect = document.getElementById('provider');
                const selectedProvider = providerSelect ? providerSelect.value : '';
                
                // Use streaming endpoint for real-time responses
                const response = await fetch('/chat/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: message,
                        user_id: 'user_' + Date.now(),
                        conversation_id: 'modern_chat_' + Date.now(),
                        provider: selectedProvider || undefined,
                        agent_type: 'reasoning'
                    }),
                    signal: currentController.signal
                });

                if (!response.ok) {
                    // Fallback to regular streaming
                    const fallbackResponse = await fetch('/chat/stream', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            message: message,
                            user_id: 'user_' + Date.now(),
                            conversation_id: 'modern_chat_' + Date.now()
                        }),
                        signal: currentController.signal
                    });
                    
                    if (!fallbackResponse.ok) {
                        throw new Error(`HTTP error! status: ${fallbackResponse.status}`);
                    }
                    
                    return handleBasicStream(fallbackResponse);
                }

                // Handle enhanced agent response with LangChain features
                const reader = response.body.getReader();
                let currentToolCalls = [];
                let currentReasoningSteps = [];
                let currentArtifacts = [];
                let messageElement = null;
                
                // Hide typing indicator and create initial message
                hideTyping();
                const messagesContainer = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message message-assistant';
                
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble';
                bubble.innerHTML = '';
                
                const time = document.createElement('div');
                time.className = 'message-time';
                time.textContent = new Date().toLocaleTimeString();
                
                messageDiv.appendChild(bubble);
                messageDiv.appendChild(time);
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // Optimization: batch updates
                let updateCounter = 0;
                let rafPending = false;
                const batchSize = 5;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = new TextDecoder().decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                switch (data.type) {
                                    case 'content':
                                        assistantMessage += data.data;
                                        updateCounter++;
                                        
                                        // Batch DOM updates for better performance
                                        if (updateCounter >= batchSize && !rafPending) {
                                            rafPending = true;
                                            requestAnimationFrame(() => {
                                                // Use markdown rendering for formatted text
                                                if (typeof marked !== 'undefined') {
                                                    try {
                                                        bubble.innerHTML = marked.parse(assistantMessage);
                                                    } catch (e) {
                                                bubble.textContent = assistantMessage;
                                                    }
                                                } else {
                                                    bubble.textContent = assistantMessage;
                                                }
                                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                rafPending = false;
                                                updateCounter = 0;
                                            });
                                        }
                                        break;
                                        
                                    case 'tool_call':
                                        currentToolCalls.push(data.data);
                                        const toolElement = createToolCallElement(data.data);
                                        messageDiv.appendChild(toolElement);
                                        // Throttle scroll updates
                                        if (!rafPending) {
                                            rafPending = true;
                                            requestAnimationFrame(() => {
                                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                rafPending = false;
                                            });
                                        }
                                        break;
                                        
                                    case 'reasoning_step':
                                        currentReasoningSteps.push(data.data);
                                        const reasoningElement = createReasoningElement(data.data, currentReasoningSteps.length - 1);
                                        messageDiv.appendChild(reasoningElement);
                                        // Throttle scroll updates
                                        if (!rafPending) {
                                            rafPending = true;
                                            requestAnimationFrame(() => {
                                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                                rafPending = false;
                                            });
                                        }
                                        break;
                                        
                                    case 'artifact':
                                        currentArtifacts.push(data.data);
                                        const artifactElement = createArtifactElement(data.data);
                                        messageDiv.appendChild(artifactElement);
                                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                        break;
                                        
                                    case 'workflow_update':
                                        updateWorkflowVisualization(data.data);
                                        break;
                                        
                                    case 'status':
                                        updateAgentStatus(data.data);
                                        break;
                                }
                            } catch (e) {
                                // Ignore JSON parse errors
                            }
                        }
                    }
                }
                
                // Final update to display any remaining content with markdown
                if (typeof marked !== 'undefined') {
                    try {
                        bubble.innerHTML = marked.parse(assistantMessage);
                    } catch (e) {
                bubble.textContent = assistantMessage;
                    }
                } else {
                    bubble.textContent = assistantMessage;
                }
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

            } catch (error) {
                hideTyping();
                if (error.name !== 'AbortError') {
                    addMessage('Sorry, I encountered an error. Please try again.', false);
                    console.error('Chat error:', error);
                }
            } finally {
                sendIcon.textContent = '📤';
                currentController = null;
                
                // Add voice synthesis if enabled (like Grok/GPT)
                if (voiceEnabled && assistantMessage && assistantMessage.trim().length > 0) {
                    synthesizeVoiceResponse(assistantMessage);
                }
            }
        }

        // Setup additional event listeners after DOM is ready
        function setupAdditionalEventListeners() {
        // Mouse tracking for focus glow
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
                if (chatInput && focusGlow && document.activeElement === chatInput) {
                focusGlow.style.transform = `translate(${mouseX - 400}px, ${mouseY - 400}px)`;
            }
        });

            // Additional input event listeners for command palette
            if (chatInput) {
        chatInput.addEventListener('input', (e) => {
            adjustTextareaHeight();
            updateSendButton();
            
            const value = e.target.value;
            if (value.startsWith('/') && !value.includes(' ')) {
                showCommandPalette();
                
                if (!commandPalette) return;
                const items = commandPalette.querySelectorAll('.command-item');
                let foundIndex = -1;
                items.forEach((item, index) => {
                    const prefix = item.getAttribute('data-prefix');
                    if (prefix.startsWith(value)) {
                        foundIndex = index;
                    }
                });
                activeSuggestion = foundIndex;
                updateActiveSuggestion();
            } else {
                hideCommandPalette();
            }
        });
            }
            
            // Command palette click handlers
            if (commandPalette) {
                commandPalette.addEventListener('click', (e) => {
                    const item = e.target.closest('.command-item');
                    if (item) {
                        applyCommand(item.getAttribute('data-prefix'));
                    }
                });
            }

            // Suggestion button handlers
            document.querySelectorAll('.suggestion-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const command = btn.getAttribute('data-command');
                    applyCommand(command);
                });
            });

            // Click outside to hide command palette
            if (commandPalette && commandBtn) {
                document.addEventListener('click', (e) => {
                    if (!commandPalette.contains(e.target) && !commandBtn.contains(e.target)) {
                        hideCommandPalette();
                    }
                });
            }
        }

        
        // Modern AI Voice Input Component with Real Audio
        class ConversationalVoiceChat {
            constructor() {
                this.isRecording = false;
                this.isListening = false;
                this.isProcessing = false;
                this.time = 0;
                this.timer = null;
                this.visualizerBars = 48;
                this.voiceEnabled = false;
                this.conversationMode = false;
                
                // Audio components
                this.mediaRecorder = null;
                this.audioStream = null;
                this.audioChunks = [];
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.dataArray = null;
                
                // WebSocket for real-time conversation
                this.socket = null;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                // DOM elements
                this.voiceButton = document.getElementById('voiceButton');
                this.micIcon = document.getElementById('micIcon');
                this.recordingSpinner = document.getElementById('recordingSpinner');
                this.voiceTimer = document.getElementById('voiceTimer');
                this.voiceVisualizer = document.getElementById('voiceVisualizer');
                this.voiceStatus = document.getElementById('voiceStatus');
                
                this.init();
            }

            async init() {
                console.log('🎙️ Initializing Conversational Voice Chat...');
                this.setupEventListeners();
                await this.initializeWebSocket();
            }

            setupEventListeners() {
                if (this.voiceButton) {
                    this.voiceButton.addEventListener('click', () => this.toggleVoiceMode());
                }
                
                // Add keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'v' && e.ctrlKey) {
                        e.preventDefault();
                        this.toggleVoiceMode();
                    }
                    if (e.key === ' ' && e.ctrlKey && this.conversationMode) {
                        e.preventDefault();
                        this.toggleRecording();
                    }
                });
            }

            async initializeWebSocket() {
                try {
                    console.log('🔌 Connecting to voice chat WebSocket...');
                    this.socket = new WebSocket(`ws://${window.location.host}/ws/voice-chat`);
                    
                    this.socket.onopen = () => {
                        console.log('✅ Connected to NIS voice backend');
                        this.reconnectAttempts = 0;
                        this.updateStatus('Connected to voice backend', 'success');
                    };
                    
                    this.socket.onmessage = async (event) => {
                        await this.handleVoiceResponse(event);
                    };
                    
                    this.socket.onclose = () => {
                        console.log('❌ Disconnected from voice backend');
                        this.updateStatus('Disconnected from voice backend', 'error');
                        this.attemptReconnect();
                    };
                    
                    this.socket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.updateStatus('Connection error', 'error');
                    };
                    
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                    this.updateStatus('Failed to connect to voice backend', 'error');
                }
            }

            attemptReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`🔄 Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
                    setTimeout(() => this.initializeWebSocket(), 2000 * this.reconnectAttempts);
                }
            }

            async toggleVoiceMode() {
                // ✅ SIMPLIFIED: Toggle recording on/off with clicks
                if (!this.voiceEnabled) {
                    // First click: Start voice mode and recording
                    this.voiceEnabled = true;
                    await this.startVoiceMode();
                } else if (!this.isRecording) {
                    // Already in voice mode but not recording: Start recording
                    await this.startRecording();
                } else {
                    // Currently recording: Stop recording and send
                    this.stopRecording();
                }
                
                this.updateVoiceButton();
            }

            async startVoiceMode() {
                try {
                    console.log('🎙️ Starting conversational voice mode...');
                    console.log('🔍 DEBUG: Initial state check');
                    console.log('  - voiceEnabled:', this.voiceEnabled);
                    console.log('  - isRecording:', this.isRecording);
                    console.log('  - WebSocket state:', this.socket ? this.socket.readyState : 'no socket');
                    
                    // ✅ CRITICAL: Wait for WebSocket to be fully connected
                    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
                        console.log('⏳ Waiting for WebSocket connection...');
                        await new Promise((resolve, reject) => {
                            const timeout = setTimeout(() => reject(new Error('WebSocket connection timeout')), 5000);
                            const checkConnection = setInterval(() => {
                                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                                    clearInterval(checkConnection);
                                    clearTimeout(timeout);
                                    console.log('✅ WebSocket ready');
                                    resolve();
                                }
                            }, 100);
                        });
                    }
                    
                    // Request microphone permissions
                    console.log('🔍 Requesting microphone access...');
                    this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 44100
                        } 
                    });
                    
                    console.log('🎤 Microphone access granted');
                    console.log('🔍 DEBUG: Audio stream tracks:', this.audioStream.getTracks().map(t => ({ 
                        kind: t.kind, 
                        enabled: t.enabled, 
                        muted: t.muted,
                        readyState: t.readyState
                    })));
                    
                    // Setup audio context and analyzer
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(this.audioStream);
                    
                    this.analyser.fftSize = 256;
                    this.microphone.connect(this.analyser);
                    
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    
                    console.log('🎛️ Audio context initialized');
                    console.log('🔍 DEBUG: AudioContext state:', this.audioContext.state);
                    
                    // 🎨 Show visualizer and stop button
                    const visualizerContainer = document.getElementById('voiceVisualizerContainer');
                    if (visualizerContainer) {
                        visualizerContainer.style.display = 'flex';
                        console.log('✅ Visualizer container shown');
                    }
                    
                    const voiceStopBtn = document.getElementById('voiceStopBtn');
                    if (voiceStopBtn) {
                        voiceStopBtn.style.display = 'inline-block';
                        console.log('✅ Stop button shown');
                    }
                    
                    // 🎨 Initialize AMAZING visualizer
                    if (window.voiceVisualizer) {
                        window.voiceVisualizer.start(this.analyser);
                        console.log('✨ Visualizer started');
                    }
                    
                    // Show helpful message - SIMPLIFIED MODE
                    this.updateStatus('Ready to record', 'success');
                    addMessage('🎙️ Voice chat ready! Click the microphone button to start recording, click again to stop and send. Click 🛑 to exit voice mode.', false, 'system');
                    
                    // ✅ SIMPLIFIED: Auto-start first recording
                    console.log('🔍 Auto-starting first recording...');
                    await this.startRecording();
                    
                } catch (error) {
                    console.error('❌ Failed to start voice mode:', error);
                    console.error('🔍 DEBUG: Error details:', {
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    });
                    this.updateStatus('Microphone access denied', 'error');
                    addMessage('❌ Microphone access denied. Please allow microphone permissions and try again.', false, 'system');
                    this.voiceEnabled = false;
                    this.conversationMode = false;
                }
            }

            async stopVoiceMode() {
                console.log('🛑 Stopping voice mode...');
                console.log('🔍 DEBUG: Stopping voice mode - current state:', {
                    voiceEnabled: this.voiceEnabled,
                    isRecording: this.isRecording,
                    conversationMode: this.conversationMode,
                    hasAudioStream: !!this.audioStream,
                    hasAudioContext: !!this.audioContext
                });
                
                this.voiceEnabled = false;
                this.conversationMode = false;
                this.stopRecording();
                
                // 🎨 Stop and hide visualizer
                if (window.voiceVisualizer) {
                    window.voiceVisualizer.stop();
                    console.log('✅ Visualizer stopped');
                }
                
                const visualizerContainer = document.getElementById('voiceVisualizerContainer');
                if (visualizerContainer) {
                    visualizerContainer.style.display = 'none';
                    console.log('✅ Visualizer container hidden');
                }
                
                // 🎨 Hide stop button
                const voiceStopBtn = document.getElementById('voiceStopBtn');
                if (voiceStopBtn) {
                    voiceStopBtn.style.display = 'none';
                    console.log('✅ Stop button hidden');
                }
                
                // Stop audio stream
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => {
                        track.stop();
                        console.log('✅ Audio track stopped:', track.kind);
                    });
                    this.audioStream = null;
                }
                
                // Close audio context
                if (this.audioContext && this.audioContext.state !== 'closed') {
                    await this.audioContext.close();
                    console.log('✅ AudioContext closed');
                    this.audioContext = null;
                }
                
                this.updateStatus('Voice mode disabled', 'info');
                addMessage('🔇 Voice chat deactivated. You\'re back in regular chat mode. Click the microphone to start again.', false, 'system');
                console.log('✅ Voice mode fully stopped');
            }

            startListening() {
                if (!this.conversationMode) return;
                
                this.isListening = true;
                console.log('👂 Starting to listen for voice input...');
                this.updateStatus('Listening... Speak to chat!', 'listening');
                
                // Start voice activity detection
                this.detectVoiceActivity();
            }

            stopListening() {
                this.isListening = false;
                console.log('🔇 Stopped listening');
            }

            detectVoiceActivity() {
                if (!this.isListening || !this.analyser) return;
                
                this.analyser.getByteFrequencyData(this.dataArray);
                
                // Calculate audio level
                let sum = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    sum += this.dataArray[i];
                }
                const average = sum / this.dataArray.length;
                
                // ✅ FIXED: Lower threshold for better sensitivity (was 30, now 15)
                const threshold = 15;
                
                // Debug: Log audio level periodically
                if (Math.random() < 0.01) { // Log 1% of the time
                    console.log(`🎚️ Audio level: ${average.toFixed(1)} (threshold: ${threshold})`);
                }
                
                if (average > threshold && !this.isRecording && !this.isProcessing) {
                    console.log(`🎤 Voice activity detected! Level: ${average.toFixed(1)} > ${threshold}`);
                    this.startRecording();
                } else if (average <= threshold && this.isRecording) {
                    // Use a delay to avoid cutting off speech
                    if (!this.silenceTimer) {
                        this.silenceTimer = setTimeout(() => {
                            if (this.isRecording) {
                                console.log('🔇 Silence detected, stopping recording...');
                                this.stopRecording();
                                this.silenceTimer = null;
                            }
                        }, 1500); // 1.5 second silence threshold
                    }
                } else if (average > threshold && this.silenceTimer) {
                    // Cancel silence timer if voice detected again
                    clearTimeout(this.silenceTimer);
                    this.silenceTimer = null;
                }
                
                // Continue listening
                if (this.isListening) {
                    requestAnimationFrame(() => this.detectVoiceActivity());
                }
            }

            async startRecording() {
                if (this.isRecording || !this.audioStream) return;
                
                this.isRecording = true;
                this.audioChunks = [];
                
                console.log('🎤 Started recording...');
                this.updateStatus('Recording...', 'recording');
                
                try {
                    this.mediaRecorder = new MediaRecorder(this.audioStream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                            console.log(`📦 Audio chunk collected: ${event.data.size} bytes`);
                        }
                    };
                    
                    this.mediaRecorder.onstop = async () => {
                        console.log(`📥 Recording stopped, total chunks: ${this.audioChunks.length}`);
                        await this.processRecording();
                    };
                    
                    this.mediaRecorder.onerror = (error) => {
                        console.error('❌ MediaRecorder error:', error);
                        this.updateStatus('Recording error', 'error');
                        this.isRecording = false;
                    };
                    
                    // ✅ CRITICAL FIX: Add timeslice (100ms) so ondataavailable fires during recording
                    this.mediaRecorder.start(100);
                    this.startTimer();
                    
                    console.log('✅ MediaRecorder started successfully');
                    
                } catch (error) {
                    console.error('Failed to start recording:', error);
                    this.updateStatus('Recording failed', 'error');
                    this.isRecording = false;
                }
            }

            stopRecording() {
                if (!this.isRecording || !this.mediaRecorder) return;
                
                console.log('🛑 Stopping recording...');
                this.isRecording = false;
                this.stopTimer();
                
                if (this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
            }

            async processRecording() {
                if (this.audioChunks.length === 0) {
                    console.warn('⚠️ No audio data to process');
                    return;
                }
                
                this.isProcessing = true;
                this.updateStatus('Processing...', 'processing');
                
                try {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    console.log(`📤 Processing ${this.audioChunks.length} chunks, total size: ${audioBlob.size} bytes`);
                    
                    // ✅ CRITICAL: Check WebSocket state before sending
                    if (!this.socket) {
                        throw new Error('WebSocket not initialized');
                    }
                    
                    if (this.socket.readyState !== WebSocket.OPEN) {
                        throw new Error(`WebSocket not open (state: ${this.socket.readyState})`);
                    }
                    
                    // Send audio to backend via WebSocket with new protocol
                        const reader = new FileReader();
                    
                    reader.onerror = (error) => {
                        console.error('❌ FileReader error:', error);
                        this.updateStatus('Failed to read audio', 'error');
                        this.isProcessing = false;
                    };
                    
                        reader.onload = () => {
                        try {
                            // Convert to base64
                            const base64Audio = btoa(
                                new Uint8Array(reader.result)
                                    .reduce((data, byte) => data + String.fromCharCode(byte), '')
                            );
                            
                            console.log(`📦 Audio encoded to base64: ${base64Audio.length} characters`);
                            
                            // Send JSON message with audio_input type
                            const message = {
                                type: 'audio_input',
                                audio_data: base64Audio
                            };
                            
                            this.socket.send(JSON.stringify(message));
                            console.log('✅ Audio sent to backend successfully');
                            this.updateStatus('Sent to backend', 'processing');
                            
                        } catch (error) {
                            console.error('❌ Failed to encode/send audio:', error);
                            this.updateStatus('Send failed', 'error');
                            this.isProcessing = false;
                        }
                    };
                    
                    reader.readAsArrayBuffer(audioBlob);
                    
                } catch (error) {
                    console.error('❌ Failed to process recording:', error);
                    this.updateStatus(`Processing failed: ${error.message}`, 'error');
                    this.isProcessing = false;
                } finally {
                    // Clean up audio chunks
                    this.audioChunks = [];
                }
            }

            async handleVoiceResponse(event) {
                try {
                        const response = JSON.parse(event.data);
                    console.log('📥 Received:', response.type, response);
                    
                    switch(response.type) {
                        case 'connected':
                            console.log('✅ Connected to voice chat:', response.session_id);
                            this.updateStatus('Voice chat ready', 'success');
                            break;
                            
                        case 'transcription':
                            console.log('📝 Transcription:', response.text);
                            console.log(`⏱️ STT: ${response.latency_ms}ms`);
                            addMessage(response.text, true, 'user');
                            this.updateStatus('Transcribed', 'success');
                            break;
                            
                        case 'text_response':
                            console.log('💬 AI Response:', response.text);
                            console.log(`⏱️ LLM: ${response.latency_ms}ms`);
                            addMessage(response.text, false, 'assistant');
                            break;
                            
                        case 'audio_response':
                            console.log('🎵 Audio received');
                            const latency = response.latency;
                            console.log(`⏱️ Total: ${latency.total_ms}ms (STT: ${latency.stt_ms}ms, LLM: ${latency.llm_ms}ms, TTS: ${latency.tts_ms}ms)`);
                            
                            // ✅ Reset processing flag now that we received response
                            this.isProcessing = false;
                            
                            // Decode and play audio
                            const audioData = atob(response.audio_data);
                            const audioArray = new Uint8Array(audioData.length);
                            for (let i = 0; i < audioData.length; i++) {
                                audioArray[i] = audioData.charCodeAt(i);
                            }
                            await this.playAudioFromBytes(audioArray.buffer);
                            
                            // ✅ SIMPLIFIED: Ready for next recording
                            this.updateStatus('Ready - Click to record', 'success');
                            break;
                            
                        case 'status':
                            this.updateStatus(response.stage, 'processing');
                            break;
                            
                        case 'error':
                            console.error('❌ Error:', response.message);
                            this.updateStatus(`Error: ${response.message}`, 'error');
                            break;
                            
                        case 'status_response':
                            console.log('📊 Status:', response);
                            break;
                    }
                } catch (error) {
                    console.error('Failed to handle voice response:', error);
                    this.updateStatus('Response processing failed', 'error');
                }
            }

            async playAudioFromBytes(audioData) {
                try {
                    console.log('🔊 Playing audio response...');
                    this.updateStatus('Playing response...', 'playing');
                    
                    // Use HTML5 Audio for MP3 playback (simpler than AudioContext for MP3)
                    const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    const audio = new Audio(audioUrl);
                    
                    audio.onended = () => {
                        console.log('✅ Audio playback completed');
                        URL.revokeObjectURL(audioUrl);
                        
                        // ✅ SIMPLIFIED: Ready for next manual recording
                        this.updateStatus('Ready - Click to record again', 'success');
                    };
                    
                    audio.onerror = (error) => {
                        console.error('Audio playback error:', error);
                        URL.revokeObjectURL(audioUrl);
                        this.updateStatus('Playback failed', 'error');
                    };
                    
                    await audio.play();
                    
                } catch (error) {
                    console.error('Failed to play audio response:', error);
                    this.updateStatus('Audio playback failed', 'error');
                    
                    // Fallback to listening mode
                    if (this.conversationMode) {
                        setTimeout(() => this.startListening(), 500);
                    }
                }
            }

            async playAudioResponse(audioData) {
                try {
                    console.log('🔊 Playing audio response (legacy method)...');
                    this.updateStatus('Playing response...', 'playing');
                    
                    if (!this.audioContext) {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const audioBuffer = await this.audioContext.decodeAudioData(audioData.slice());
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.audioContext.destination);
                    
                    source.onended = () => {
                        console.log('✅ Audio playback completed');
                        if (this.conversationMode) {
                            this.updateStatus('Listening...', 'listening');
                        }
                    };
                    
                    source.start();
                    
                } catch (error) {
                    console.error('Failed to play audio response:', error);
                    this.updateStatus('Audio playback failed', 'error');
                    
                    // Fallback to listening mode
                    if (this.conversationMode) {
                        setTimeout(() => {
                            this.updateStatus('Listening...', 'listening');
                        }, 1000);
                    }
                }
            }

            updateStatus(message, type = 'info') {
                console.log(`📊 Status: ${message} (${type})`);
                
                // Update UI status if elements exist
                if (this.voiceStatus) {
                    this.voiceStatus.textContent = message;
                    this.voiceStatus.className = `voice-status ${type}`;
                }
                
                // Update voice button appearance
                this.updateVoiceButton();
            }

            updateVoiceButton() {
                if (!this.voiceButton || !this.micIcon) return;
                
                // Remove all state classes
                this.voiceButton.classList.remove('recording', 'listening', 'processing', 'playing');
                
                if (this.isRecording) {
                    this.voiceButton.classList.add('recording');
                    this.micIcon.textContent = '🔴';
                } else if (this.isProcessing) {
                    this.voiceButton.classList.add('processing');
                    this.micIcon.textContent = '⏳';
                } else if (this.isListening && this.conversationMode) {
                    this.voiceButton.classList.add('listening');
                    this.micIcon.textContent = '👂';
                } else if (this.voiceEnabled) {
                    this.micIcon.textContent = '🎙️';
                } else {
                    this.micIcon.textContent = '🎤';
                }
                
                // Update button title with clear instructions
                const status = this.isRecording ? '🔴 Recording your voice...' :
                             this.isProcessing ? '⏳ Processing your message...' :
                             this.conversationMode ? '👂 Listening - just start talking! (Click to stop)' :
                             '🎤 Click to start voice chat - I\'ll listen continuously';
                this.voiceButton.title = status;
            }

            startTimer() {
                this.time = 0;
                this.timer = setInterval(() => {
                    this.time++;
                    if (this.voiceTimer) {
                        const minutes = Math.floor(this.time / 60);
                        const seconds = this.time % 60;
                        this.voiceTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
                if (this.voiceTimer) {
                    this.voiceTimer.textContent = '0:00';
                }
            }
            
            createVisualizerBars() {
                // Legacy method for compatibility
            }
            
            bindEvents() {
                // Legacy method for compatibility
            }
            
            createVisualizerBars() {
                if (!this.voiceVisualizer) return;
                
                for (let i = 0; i < this.visualizerBars; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'visualizer-bar';
                    this.voiceVisualizer.appendChild(bar);
                }
            }
            
            bindEvents() {
                if (this.voiceButton) {
                    this.voiceButton.addEventListener('click', () => this.handleClick());
                }
            }
            
            handleClick() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
            
            async startRecording() {
                try {
                    // Request microphone access
                    this.audioStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        } 
                    });
                    
                    // Set up audio context for visualization
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(this.audioStream);
                    this.microphone.connect(this.analyser);
                    
                    this.analyser.fftSize = 256;
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);
                    
                    // Set up media recorder
                    this.mediaRecorder = new MediaRecorder(this.audioStream);
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };
                    
                    this.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                        this.processAudioRecording(audioBlob);
                    };
                    
                    // Start recording
                    this.mediaRecorder.start();
                    this.isRecording = true;
                    this.time = 0;
                    this.voiceEnabled = true;
                    
                    // Update UI
                    this.voiceButton.classList.add('recording');
                    this.micIcon.style.display = 'none';
                    this.recordingSpinner.style.display = 'block';
                    this.voiceTimer.classList.add('recording');
                    this.voiceStatus.classList.add('recording');
                    this.voiceStatus.textContent = 'Listening...';
                    
                    // Start timer
                    this.timer = setInterval(() => {
                        this.time++;
                        this.updateTimer();
                    }, 1000);
                    
                    // Start real-time visualizer
                    this.startRealTimeVisualizer();
                    
                    // Show status in chat
                    addMessage('🎙️ Voice recording started! Speak now...', false, 'system');
                    
                    console.log('Real voice recording started');
                    
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    addMessage('❌ Microphone access denied. Please allow microphone permissions.', false, 'system');
                    this.voiceStatus.textContent = 'Microphone access denied';
                }
            }
            
            stopRecording() {
                this.isRecording = false;
                
                // Stop media recorder
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.stop();
                }
                
                // Stop audio stream
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => track.stop());
                }
                
                // Close audio context
                if (this.audioContext) {
                    this.audioContext.close();
                }
                
                // Update UI
                this.voiceButton.classList.remove('recording');
                this.micIcon.style.display = 'block';
                this.recordingSpinner.style.display = 'none';
                this.voiceTimer.classList.remove('recording');
                this.voiceStatus.classList.remove('recording');
                this.voiceStatus.textContent = 'Processing...';
                
                // Stop timer
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
                
                // Stop visualizer
                this.stopVisualizer();
                
                console.log('Voice recording stopped');
            }
            
            processAudioRecording(audioBlob) {
                // Convert audio to text (placeholder - would need speech-to-text service)
                console.log('Processing audio recording:', audioBlob);
                
                // For now, just enable voice responses
                this.voiceEnabled = true;
                addMessage('🎙️ Voice responses enabled! AI will now speak its responses automatically.', false, 'system');
                
                // Reset UI
                this.voiceStatus.textContent = 'Click to speak';
                this.time = 0;
                this.updateTimer();
                
                // TODO: Send audioBlob to speech-to-text service
                // TODO: Process the transcribed text as a chat message
            }
            
            startRealTimeVisualizer() {
                const visualize = () => {
                    if (!this.isRecording || !this.analyser) return;
                    
                    requestAnimationFrame(visualize);
                    
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    const bars = this.voiceVisualizer.querySelectorAll('.visualizer-bar');
                    const step = Math.floor(this.dataArray.length / bars.length);
                    
                    bars.forEach((bar, i) => {
                        const value = this.dataArray[i * step];
                        const height = (value / 255) * 100;
                        bar.style.height = `${Math.max(4, height)}%`;
                        bar.classList.add('active');
                    });
                };
                
                visualize();
            }
            
            updateTimer() {
                const mins = Math.floor(this.time / 60);
                const secs = this.time % 60;
                const timeStr = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                if (this.voiceTimer) {
                    this.voiceTimer.textContent = timeStr;
                }
            }
            
            startVisualizer() {
                const bars = this.voiceVisualizer.querySelectorAll('.visualizer-bar');
                bars.forEach((bar, i) => {
                    bar.classList.add('active');
                    bar.style.animationDelay = `${i * 0.05}s`;
                    
                    // Random height animation
                    const animate = () => {
                        if (this.isRecording) {
                            const height = 20 + Math.random() * 80;
                            bar.style.height = `${height}%`;
                            setTimeout(animate, 100 + Math.random() * 200);
                        }
                    };
                    animate();
                });
            }
            
            stopVisualizer() {
                const bars = this.voiceVisualizer.querySelectorAll('.visualizer-bar');
                bars.forEach(bar => {
                    bar.classList.remove('active');
                    bar.style.height = '4px';
                });
            }
            
            toggleVoice() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
        }
        
        // Initialize the modern voice input (will be created after DOM loads)
        let conversationalVoice = null;
        let voiceEnabled = false;
        
        // Voice synthesis function with real audio playback
        async function synthesizeVoiceResponse(text) {
            if (!text || text.trim().length === 0) return;
            if (!conversationalVoice || !conversationalVoice.voiceEnabled) return;
            
            console.log('🎙️ Synthesizing voice for:', text.substring(0, 50) + '...');
            
            try {
                // Use Web Speech API for real TTS
                if ('speechSynthesis' in window) {
                    // Cancel any ongoing speech
                    speechSynthesis.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(cleanTextForSpeech(text));
                    
                    // Configure voice settings
                    utterance.rate = 0.9;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.8;
                    
                    // Try to use a good voice
                    const voices = speechSynthesis.getVoices();
                    const preferredVoice = voices.find(voice => 
                        voice.name.includes('Neural') || 
                        voice.name.includes('Premium') ||
                        voice.name.includes('Enhanced') ||
                        voice.lang.startsWith('en')
                    );
                    
                    if (preferredVoice) {
                        utterance.voice = preferredVoice;
                    }
                    
                    // Add event handlers
                    utterance.onstart = () => {
                        console.log('🎙️ Speech started');
                        showSpeakingIndicator();
                    };
                    
                    utterance.onend = () => {
                        console.log('🎙️ Speech ended');
                        hideSpeakingIndicator();
                    };
                    
                    utterance.onerror = (event) => {
                        console.error('🎙️ Speech error:', event.error);
                        hideSpeakingIndicator();
                    };
                    
                    // Speak the text
                    speechSynthesis.speak(utterance);
                    
                } else {
                    // Fallback to backend TTS
                    await synthesizeWithBackend(text);
                }
            } catch (error) {
                console.error('🎙️ Voice synthesis error:', error);
            }
        }
        
        // Clean text for better speech synthesis
        function cleanTextForSpeech(text) {
            return text
                .replace(/```[\s\S]*?```/g, ' code block ')
                .replace(/`([^`]+)`/g, ' $1 ')
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/\*(.*?)\*/g, '$1')
                .replace(/#{1,6}\s/g, '')
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                .replace(/[🎙️🔊🎵🎶🔇]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }
        
        // Show speaking indicator
        function showSpeakingIndicator() {
            let indicator = document.getElementById('speakingIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'speakingIndicator';
                indicator.innerHTML = '🎙️ Speaking...';
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(16, 185, 129, 0.9);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 14px;
                    z-index: 10000;
                    animation: pulse 1s infinite;
                `;
                document.body.appendChild(indicator);
            }
        }
        
        // Hide speaking indicator
        function hideSpeakingIndicator() {
            const indicator = document.getElementById('speakingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }
        
        // Fallback backend TTS
        async function synthesizeWithBackend(text) {
            try {
                // Show voice indicator
                const voiceIndicator = document.createElement('div');
                voiceIndicator.style.cssText = `
                    position: fixed; 
                    top: 20px; 
                    right: 20px; 
                    background: rgba(16, 185, 129, 0.9); 
                    color: white; 
                    padding: 8px 16px; 
                    border-radius: 20px; 
                    font-size: 14px; 
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                voiceIndicator.innerHTML = '🎙️ Speaking...';
                document.body.appendChild(voiceIndicator);
                
                // Clean text for better speech synthesis
                const cleanText = text.replace(/```[\s\S]*?```/g, '[code block]')
                                    .replace(/\*\*(.*?)\*\*/g, '$1')
                                    .replace(/\*(.*?)\*/g, '$1')
                                    .replace(/#{1,6}\s/g, '')
                                    .trim();
                
                // Synthesize speech using VibeVoice
                const response = await fetch('/communication/synthesize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: cleanText,
                        speaker: 'consciousness',
                        emotion: 'conversational'
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        voiceIndicator.innerHTML = '✅ Voice synthesized';
                        voiceIndicator.style.background = 'rgba(16, 185, 129, 0.9)';
                        console.log('✅ Voice synthesis successful');
                    } else {
                        voiceIndicator.innerHTML = '❌ Voice failed';
                        voiceIndicator.style.background = 'rgba(239, 68, 68, 0.9)';
                        console.error('Voice synthesis failed:', result.error);
                    }
                } else {
                    voiceIndicator.innerHTML = '❌ Voice error';
                    voiceIndicator.style.background = 'rgba(239, 68, 68, 0.9)';
                    console.error('Voice endpoint error:', response.status);
                }
                
                // Remove indicator after delay
                setTimeout(() => {
                    if (document.body.contains(voiceIndicator)) {
                        document.body.removeChild(voiceIndicator);
                    }
                }, 3000);
                
            } catch (error) {
                console.error('Voice synthesis error:', error);
                // Show error indicator if one exists
                const indicators = document.querySelectorAll('[style*="Speaking"]');
                indicators.forEach(indicator => {
                    indicator.innerHTML = '❌ Voice error';
                    indicator.style.background = 'rgba(239, 68, 68, 0.9)';
                });
            }
        }
        

        // Enhanced runner commands
        async function executeRunnerTool(tool, args) {
            try {
                const response = await fetch('/api/langgraph/invoke', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ tool: tool, args: args })
                });

                const result = await response.json();
                
                if (result.success) {
                    return result;
                } else {
                    throw new Error(result.error || 'Tool execution failed');
                }
            } catch (error) {
                throw error;
            }
        }


        // These event listeners are set up in setupAdditionalEventListeners() after DOM is ready

        // LangChain Agent UI Helper Functions
        function handleBasicStream(response) {
            // Fallback for basic streaming without LangChain features
            const reader = response.body.getReader();
            let assistantMessage = '';
            
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message message-assistant';
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            bubble.textContent = '';
            
            const time = document.createElement('div');
            time.className = 'message-time';
            time.textContent = new Date().toLocaleTimeString();
            
            messageDiv.appendChild(bubble);
            messageDiv.appendChild(time);
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            return reader.read().then(function processText({ done, value }) {
                if (done) return;
                
                const chunk = new TextDecoder().decode(value);
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const data = JSON.parse(line.slice(6));
                            if (data.type === 'content') {
                                assistantMessage += data.data;
                                // Use markdown rendering for formatted text
                                if (typeof marked !== 'undefined') {
                                    try {
                                        bubble.innerHTML = marked.parse(assistantMessage);
                                    } catch (e) {
                                bubble.textContent = assistantMessage;
                                    }
                                } else {
                                    bubble.textContent = assistantMessage;
                                }
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }
                        } catch (e) {
                            // Ignore JSON parse errors
                        }
                    }
                }
                
                return reader.read().then(processText);
            });
        }

        function updateWorkflowVisualization(workflowData) {
            // Create or update workflow visualization
            let workflowElement = document.querySelector('.agent-workflow');
            if (!workflowElement) {
                workflowElement = document.createElement('div');
                workflowElement.className = 'agent-workflow';
                const messagesContainer = document.getElementById('chatMessages');
                messagesContainer.appendChild(workflowElement);
            }
            
            workflowElement.innerHTML = `
                <div class="workflow-header">
                    <span>🔄</span>
                    <span>Agent Workflow</span>
                </div>
                <div class="workflow-steps">
                    ${workflowData.steps.map((step, index) => `
                        <div class="workflow-step ${step.status}">
                            <div class="step-icon ${step.status}">
                                ${step.status === 'completed' ? '✓' : step.status === 'active' ? '⟳' : index + 1}
                            </div>
                            <span>${step.name}</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function updateAgentStatus(statusData) {
            // Update agent status in the UI
            const statusElement = document.querySelector('.agent-status');
            if (statusElement) {
                statusElement.textContent = statusData.message;
                statusElement.className = `agent-status ${statusData.type}`;
            }
        }

        function openArtifact(artifactId) {
            // Open artifact in a modal or side panel
            console.log('Opening artifact:', artifactId);
            // Implementation for artifact viewing
        }

        function formatMessage(content) {
            if (typeof content !== 'string') {
                content = JSON.stringify(content, null, 2);
            }
            
            // Enhanced markdown-like formatting for LangChain
            content = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`(.*?)`/g, '<code style="background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 4px;">$1</code>')
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<div class="code-block"><div class="code-header"><span class="code-language">$1</span></div><pre>$2</pre></div>')
                .replace(/\n/g, '<br>');

            return content;
        }



        // Tool call interaction handlers
        document.addEventListener('click', (e) => {
            if (e.target.closest('.tool-header')) {
                const toolCall = e.target.closest('.tool-call');
                const content = toolCall?.querySelector('.tool-content');
                if (content) content.classList.toggle('expanded');
            }
        });

        // Initial setup
        adjustTextareaHeight();
        updateSendButton();
        
        // Welcome message with LangChain features
        setTimeout(() => {
            addMessage('🚀 **NIS Protocol Modern Chat** - Enhanced with LangChain Agent UI\n\n**Features:**\n• Real-time tool call visualization\n• Agent reasoning steps\n• Artifact rendering\n• Workflow tracking\n• Terminal integration\n\nType a command starting with "/" or ask me anything!', false);
        }, 1000);

        // ====== NIS STATE MANAGEMENT INTEGRATION ======
        
        class ModernChatComponent {
            constructor() {
                this.setupStateManagement();
                this.setupRealTimeUpdates();
                this.setupToolCallVisualization();
            }
            
            setupStateManagement() {
                // Register with NIS State Manager
                if (window.nisStateManager) {
                    window.nisStateManager.registerComponent('modern_chat', this);
                    console.log('🧠 Modern Chat registered with NIS State Manager');
                } else {
                    console.warn('⚠️ NIS State Manager not available');
                }
            }
            
            setupRealTimeUpdates() {
                // Listen for real-time events
                if (window.nisStateManager) {
                    window.nisStateManager.client.on('chat_message', ({ data }) => {
                        this.handleRealTimeMessage(data);
                    });
                    
                    window.nisStateManager.client.on('agent_status_change', ({ data }) => {
                        this.updateAgentStatus(data);
                    });
                    
                    window.nisStateManager.client.on('backend_instruction', ({ data }) => {
                        this.handleBackendInstruction(data);
                    });
                    
                    window.nisStateManager.client.on('recommendation_generated', ({ data }) => {
                        this.showRecommendation(data);
                    });
                }
            }
            
            setupToolCallVisualization() {
                // Enhanced tool call visualization with real-time updates
                this.activeToolCalls = new Map();
                this.workflowSteps = [];
            }
            
            onStateUpdate(state) {
                console.log('📊 Modern Chat received state update:', Object.keys(state));
                
                // Update system status in header
                if (state.system_health) {
                    this.updateSystemStatus(state.system_health);
                }
                
                // Update active agents display (disabled to prevent spam)
                // if (state.active_agents) {
                //     this.updateActiveAgentsDisplay(state.active_agents);
                // }
                
                // Update performance metrics
                if (state.average_response_time) {
                    this.updatePerformanceDisplay(state.average_response_time);
                }
            }
            
            onEvent(eventType, data) {
                console.log('🎯 Modern Chat received event:', eventType, data);
                
                switch (eventType) {
                    case 'tool_call_started':
                        this.visualizeToolCallStart(data);
                        break;
                    case 'tool_call_completed':
                        this.visualizeToolCallComplete(data);
                        break;
                    case 'reasoning_step':
                        this.addReasoningStep(data);
                        break;
                    case 'workflow_update':
                        this.updateWorkflow(data);
                        break;
                }
            }
            
            updateSystemStatus(health) {
                // Update system status indicator
                const statusIndicator = document.querySelector('.system-status') || this.createStatusIndicator();
                statusIndicator.className = `system-status ${health}`;
                statusIndicator.textContent = `System: ${health}`;
            }
            
            createStatusIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'system-status';
                indicator.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 8px 16px;
                    border-radius: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    font-size: 12px;
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
                return indicator;
            }
            
            updateActiveAgentsDisplay(agents) {
                // Update active agents display without spamming chat
                const agentCount = Object.keys(agents).length;
                const agentNames = Object.keys(agents).join(', ');
                
                // Update status display instead of adding chat messages
                let statusDisplay = document.querySelector('.active-agents-status');
                if (!statusDisplay) {
                    statusDisplay = document.createElement('div');
                    statusDisplay.className = 'active-agents-status';
                    statusDisplay.style.cssText = `
                        position: fixed;
                        top: 100px;
                        right: 20px;
                        padding: 8px 16px;
                        border-radius: 20px;
                        background: rgba(59, 130, 246, 0.1);
                        color: #3b82f6;
                        font-size: 12px;
                        z-index: 1000;
                        border: 1px solid rgba(59, 130, 246, 0.2);
                        max-width: 300px;
                        word-wrap: break-word;
                    `;
                    document.body.appendChild(statusDisplay);
                }
                statusDisplay.textContent = `🤖 ${agentCount} agents active: ${agentNames}`;
            }
            
            updatePerformanceDisplay(responseTime) {
                // Update performance indicator
                const perfIndicator = document.querySelector('.performance-indicator') || this.createPerformanceIndicator();
                perfIndicator.textContent = `⚡ ${Math.round(responseTime)}ms`;
            }
            
            createPerformanceIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'performance-indicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    right: 20px;
                    padding: 4px 12px;
                    border-radius: 15px;
                    background: rgba(16, 185, 129, 0.2);
                    color: #10b981;
                    font-size: 11px;
                    z-index: 1000;
                `;
                document.body.appendChild(indicator);
                return indicator;
            }
            
            handleRealTimeMessage(messageData) {
                // Handle real-time incoming messages
                if (messageData.type === 'tool_call') {
                    this.visualizeToolCall(messageData);
                } else if (messageData.type === 'reasoning') {
                    this.addReasoningStep(messageData);
                } else {
                    this.addMessage(messageData.content, false);
                }
            }
            
            visualizeToolCall(toolCallData) {
                // Create enhanced tool call visualization
                const toolCallElement = document.createElement('div');
                toolCallElement.className = 'tool-call enhanced';
                toolCallElement.innerHTML = `
                    <div class="tool-header">
                        <span class="tool-icon">🔧</span>
                        <span class="tool-name">${toolCallData.tool_name}</span>
                        <span class="tool-status ${toolCallData.status}">${toolCallData.status}</span>
                        <span class="tool-timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="tool-content">
                        <div class="tool-input">
                            <strong>Input:</strong>
                            <pre>${JSON.stringify(toolCallData.input, null, 2)}</pre>
                        </div>
                        ${toolCallData.output ? `
                            <div class="tool-output">
                                <strong>Output:</strong>
                                <pre>${JSON.stringify(toolCallData.output, null, 2)}</pre>
                            </div>
                        ` : ''}
                    </div>
                `;
                
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.appendChild(toolCallElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
            
            addReasoningStep(stepData) {
                // Add reasoning step visualization
                const reasoningElement = document.createElement('div');
                reasoningElement.className = 'reasoning-step';
                reasoningElement.innerHTML = `
                    <div style="background: rgba(139, 92, 246, 0.1); border-left: 3px solid #8b5cf6; 
                                padding: 12px; margin: 8px 0; border-radius: 0 8px 8px 0;">
                        <strong>🧠 Reasoning:</strong> ${stepData.step}
                        ${stepData.confidence ? `<span style="float: right; color: #8b5cf6;">${Math.round(stepData.confidence * 100)}%</span>` : ''}
                    </div>
                `;
                
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.appendChild(reasoningElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
            
            showRecommendation(recommendation) {
                // Show AI recommendation with enhanced styling
                this.addSystemMessage(`💡 **AI Recommendation:** ${recommendation.message}`, 'recommendation');
            }
            
            addSystemMessage(message, type = 'info') {
                const colors = {
                    info: '#06b6d4',
                    recommendation: '#10b981',
                    warning: '#f59e0b',
                    error: '#ef4444'
                };
                
                const messageElement = document.createElement('div');
                messageElement.className = `system-message ${type}`;
                messageElement.innerHTML = `
                    <div style="background: rgba(${this.hexToRgb(colors[type])}, 0.1); 
                                border: 1px solid ${colors[type]}; 
                                border-radius: 8px; padding: 12px; margin: 8px 0; 
                                color: ${colors[type]};">
                        ${message}
                    </div>
                `;
                
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.appendChild(messageElement);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
            
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? 
                    `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                    '255, 255, 255';
            }
        }
        
        // 🎨 AMAZING VOICE VISUALIZER - GPT + GROK + APPLE HYBRID
        class VoiceVisualizer {
            constructor() {
                this.container = document.getElementById('voiceVisualizerContainer');
                this.canvas = document.getElementById('voiceVisualizerCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.analyser = null;
                this.dataArray = null;
                this.bufferLength = 0;
                
                this.isActive = false;
                this.animationFrame = null;
                
                // Particle system for organic movement
                this.particles = [];
                this.particleCount = 60;
                
                // Color palette (blue, purple, pink, orange)
                this.colors = [
                    { r: 59, g: 130, b: 246, name: 'blue' },      // Blue
                    { r: 147, g: 51, b: 234, name: 'purple' },    // Purple
                    { r: 236, g: 72, b: 153, name: 'pink' },      // Pink
                    { r: 251, g: 146, b: 60, name: 'orange' }     // Orange
                ];
                
                // Animation state
                this.time = 0;
                this.baseAmplitude = 0;
                this.targetAmplitude = 0;
                
                this.initParticles();
            }
            
            initParticles() {
                this.particles = [];
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const angle = (i / this.particleCount) * Math.PI * 2;
                    const radius = 100 + Math.random() * 50;
                    
                    this.particles.push({
                        angle: angle,
                        radius: radius,
                        baseRadius: radius,
                        speed: 0.001 + Math.random() * 0.002,
                        size: 2 + Math.random() * 3,
                        colorIndex: Math.floor(Math.random() * this.colors.length),
                        offset: Math.random() * Math.PI * 2
                    });
                }
            }
            
            start(analyser) {
                console.log('🎨 Starting AMAZING visualizer...');
                this.analyser = analyser;
                this.bufferLength = analyser.frequencyBinCount;
                this.dataArray = new Uint8Array(this.bufferLength);
                
                this.isActive = true;
                this.container.classList.add('active');
                
                this.animate();
            }
            
            stop() {
                console.log('🎨 Stopping visualizer...');
                this.isActive = false;
                this.container.classList.remove('active');
                
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            getAudioLevel() {
                if (!this.analyser || !this.dataArray) return 0;
                
                this.analyser.getByteFrequencyData(this.dataArray);
                
                // Calculate average amplitude
                let sum = 0;
                for (let i = 0; i < this.bufferLength; i++) {
                    sum += this.dataArray[i];
                }
                return sum / this.bufferLength / 255; // Normalize to 0-1
            }
            
            animate() {
                if (!this.isActive) return;
                
                this.animationFrame = requestAnimationFrame(() => this.animate());
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Get audio level
                const audioLevel = this.getAudioLevel();
                this.targetAmplitude = audioLevel;
                
                // Smooth transition
                this.baseAmplitude += (this.targetAmplitude - this.baseAmplitude) * 0.1;
                
                // Clear with fade effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.time += 0.01;
                
                // ===== LAYER 1: GPT-style ORB (center glow) =====
                const orbRadius = 80 + this.baseAmplitude * 120;
                const orbGradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, orbRadius
                );
                
                // Dynamic color based on audio
                const colorIndex = Math.floor(this.time * 2) % this.colors.length;
                const color1 = this.colors[colorIndex];
                const color2 = this.colors[(colorIndex + 1) % this.colors.length];
                
                orbGradient.addColorStop(0, `rgba(${color1.r}, ${color1.g}, ${color1.b}, ${0.8 * (1 + this.baseAmplitude)})`);
                orbGradient.addColorStop(0.5, `rgba(${color2.r}, ${color2.g}, ${color2.b}, ${0.4 * (1 + this.baseAmplitude)})`);
                orbGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = orbGradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, orbRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // ===== LAYER 2: GROK-style WAVEFORMS (circular bars) =====
                const barCount = 64;
                const barRadius = 120;
                const barMaxHeight = 60 + this.baseAmplitude * 40;
                
                for (let i = 0; i < barCount; i++) {
                    const angle = (i / barCount) * Math.PI * 2 - Math.PI / 2;
                    
                    // Get frequency data for this bar
                    const dataIndex = Math.floor((i / barCount) * this.bufferLength);
                    const barHeight = this.dataArray ? (this.dataArray[dataIndex] / 255) * barMaxHeight : barMaxHeight * 0.3;
                    
                    const x1 = centerX + Math.cos(angle) * barRadius;
                    const y1 = centerY + Math.sin(angle) * barRadius;
                    const x2 = centerX + Math.cos(angle) * (barRadius + barHeight);
                    const y2 = centerY + Math.sin(angle) * (barRadius + barHeight);
                    
                    // Color based on position (gradient around circle)
                    const colorProgress = i / barCount;
                    const barColorIndex = Math.floor(colorProgress * this.colors.length);
                    const barColor = this.colors[barColorIndex];
                    
                    this.ctx.strokeStyle = `rgba(${barColor.r}, ${barColor.g}, ${barColor.b}, ${0.6 + barHeight / barMaxHeight * 0.4})`;
                    this.ctx.lineWidth = 3;
                    this.ctx.lineCap = 'round';
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
                
                // ===== LAYER 3: APPLE-style PARTICLES (organic glow) =====
                this.particles.forEach((particle, index) => {
                    // Animate particle
                    particle.angle += particle.speed;
                    
                    // Audio-reactive radius
                    const audioBoost = this.baseAmplitude * 30 * Math.sin(this.time * 2 + particle.offset);
                    particle.radius = particle.baseRadius + audioBoost;
                    
                    const x = centerX + Math.cos(particle.angle) * particle.radius;
                    const y = centerY + Math.sin(particle.angle) * particle.radius;
                    
                    // Dynamic color
                    const color = this.colors[particle.colorIndex];
                    const alpha = 0.3 + this.baseAmplitude * 0.5;
                    
                    // Glow effect
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, particle.size * 3);
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, particle.size * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // ===== LAYER 4: EDGE LIGHTING (rotating gradient ring) =====
                const ringRadius = 180;
                const ringWidth = 3;
                const segments = 120;
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2 + this.time;
                    const nextAngle = ((i + 1) / segments) * Math.PI * 2 + this.time;
                    
                    // Color cycling
                    const colorProgress = (i / segments + this.time * 0.1) % 1;
                    const colorIndex = Math.floor(colorProgress * this.colors.length);
                    const nextColorIndex = (colorIndex + 1) % this.colors.length;
                    const colorMix = (colorProgress * this.colors.length) % 1;
                    
                    const color1 = this.colors[colorIndex];
                    const color2 = this.colors[nextColorIndex];
                    
                    const r = color1.r + (color2.r - color1.r) * colorMix;
                    const g = color1.g + (color2.g - color1.g) * colorMix;
                    const b = color1.b + (color2.b - color1.b) * colorMix;
                    
                    const alpha = 0.4 + this.baseAmplitude * 0.6;
                    
                    this.ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    this.ctx.lineWidth = ringWidth + this.baseAmplitude * 2;
                    this.ctx.lineCap = 'round';
                    
                    const x1 = centerX + Math.cos(angle) * ringRadius;
                    const y1 = centerY + Math.sin(angle) * ringRadius;
                    const x2 = centerX + Math.cos(nextAngle) * ringRadius;
                    const y2 = centerY + Math.sin(nextAngle) * ringRadius;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                }
                
                // ===== LAYER 5: CENTER HIGHLIGHT (breathing core) =====
                const coreSize = 20 + this.baseAmplitude * 30;
                const coreGradient = this.ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, coreSize
                );
                
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                coreGradient.addColorStop(0.3, `rgba(${color1.r}, ${color1.g}, ${color1.b}, 0.8)`);
                coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                
                this.ctx.fillStyle = coreGradient;
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);
                this.ctx.fill();
            }
        }
        
        // Initialize visualizer globally
        window.voiceVisualizer = new VoiceVisualizer();
        
        // Initialize Modern Chat Component
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize DOM elements first
            initializeDOMElements();
            
            // Setup additional event listeners
            setupAdditionalEventListeners();

            window.modernChatComponent = new ModernChatComponent();
            console.log('🚀 Modern Chat Component initialized with real-time state management');
            
            // Initialize conversational voice chat AFTER DOM is ready
            conversationalVoice = new ConversationalVoiceChat();
            console.log('🎙️ Conversational voice chat initialized');
            
            // Initialize development tools
            initializeDevTools();
            
            // Add DEV MODE indicator to title
            document.title = "[DEV] " + document.title;

            // Initial setup calls
            adjustTextareaHeight();
            updateSendButton();
        });
        
        // Development mode settings
        const devMode = {
            showRawResponses: false,
            showTimings: false,
            selectedEndpoint: '/chat/stream',
            networkLogs: []
        };
        
        // Development Tools Functions
        function initializeDevTools() {
            // Toggle dev tools panel
            document.getElementById('toggleDevTools').addEventListener('click', () => {
                const panel = document.getElementById('devToolsPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            });
            
            // Close dev tools panel
            document.getElementById('closeDevTools').addEventListener('click', () => {
                document.getElementById('devToolsPanel').style.display = 'none';
            });
            
            // Endpoint selection
            document.getElementById('endpointSelect').addEventListener('change', (e) => {
                devMode.selectedEndpoint = e.target.value;
                console.log(`[DEV] Endpoint changed to: ${devMode.selectedEndpoint}`);
            });
            
            // Test endpoint
            document.getElementById('testEndpoint').addEventListener('click', async () => {
                const endpoint = devMode.selectedEndpoint;
                logNetworkRequest('TEST', endpoint, 'Testing endpoint');
                
                try {
                    const startTime = performance.now();
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: "TEST_MESSAGE_FROM_DEV_TOOLS",
                            user_id: "dev_test_user",
                            stream: endpoint === '/chat/stream'
                        })
                    });
                    
                    const endTime = performance.now();
                    const duration = Math.round(endTime - startTime);
                    
                    if (response.ok) {
                        if (endpoint === '/chat/stream') {
                            logNetworkRequest('SUCCESS', endpoint, `Stream connection established (${duration}ms)`);
                        } else {
                            const data = await response.json();
                            logNetworkRequest('SUCCESS', endpoint, `Response received (${duration}ms): ${JSON.stringify(data).substring(0, 100)}...`);
                        }
                    } else {
                        logNetworkRequest('ERROR', endpoint, `Error ${response.status}: ${response.statusText} (${duration}ms)`);
                    }
                } catch (error) {
                    logNetworkRequest('ERROR', endpoint, `Exception: ${error.message}`);
                }
            });
            
            // Debug options
            document.getElementById('showRawResponse').addEventListener('change', (e) => {
                devMode.showRawResponses = e.target.checked;
                console.log(`[DEV] Show raw responses: ${devMode.showRawResponses}`);
            });
            
            document.getElementById('showTimings').addEventListener('change', (e) => {
                devMode.showTimings = e.target.checked;
                console.log(`[DEV] Show timings: ${devMode.showTimings}`);
            });
            
            // WebSocket testing
            document.getElementById('testWebSocket').addEventListener('click', () => {
                // Test WebSocket connection
                const ws = new WebSocket(`ws://${window.location.host}/ws`);
                
                ws.onopen = () => {
                    document.getElementById('wsStatus').textContent = 'WebSocket: Connected';
                    document.getElementById('wsStatus').style.color = '#10b981';
                    logNetworkRequest('WS', '/ws', 'WebSocket connection established');
                };
                
                ws.onclose = () => {
                    document.getElementById('wsStatus').textContent = 'WebSocket: Disconnected';
                    document.getElementById('wsStatus').style.color = '#ef4444';
                    logNetworkRequest('WS', '/ws', 'WebSocket connection closed');
                };
                
                ws.onerror = (error) => {
                    document.getElementById('wsStatus').textContent = 'WebSocket: Error';
                    document.getElementById('wsStatus').style.color = '#ef4444';
                    logNetworkRequest('WS_ERROR', '/ws', `WebSocket error: ${error.message || 'Unknown error'}`);
                };
                
                // Close after 5 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                    }
                }, 5000);
            });
            
            // Send test event
            document.getElementById('sendTestEvent').addEventListener('click', () => {
                // Create a test event
                const testEvent = {
                    type: 'TEST_EVENT',
                    data: {
                        message: 'This is a test event from the dev tools',
                        timestamp: new Date().toISOString()
                    }
                };
                
                // Send via fetch to a test endpoint
                fetch('/api/test/event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(testEvent)
                })
                .then(response => {
                    if (response.ok) {
                        logNetworkRequest('EVENT', '/api/test/event', 'Test event sent successfully');
                    } else {
                        logNetworkRequest('EVENT_ERROR', '/api/test/event', `Error ${response.status}: ${response.statusText}`);
                    }
                })
                .catch(error => {
                    logNetworkRequest('EVENT_ERROR', '/api/test/event', `Exception: ${error.message}`);
                });
            });
            
            // Clear network log
            document.getElementById('clearNetworkLog').addEventListener('click', () => {
                devMode.networkLogs = [];
                document.getElementById('networkLog').innerHTML = '<div>No requests logged yet</div>';
            });
            
            // Test audio playback
            document.getElementById('testAudio').addEventListener('click', () => {
                // Create a simple sine wave audio for testing
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 440; // A4 note
                gainNode.gain.value = 0.5;
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Play for 1 second
                oscillator.start();
                addMessage('🔊 Testing audio playback...', false, 'system');
                
                setTimeout(() => {
                    oscillator.stop();
                    addMessage('✅ Audio test complete. Did you hear a beep?', false, 'system');
                }, 1000);
                
                // Also test the Audio API
                try {
                    const testAudio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
                    testAudio.play().then(() => {
                        console.log('Audio API test successful');
                    }).catch(err => {
                        console.error('Audio API test failed:', err);
                        addMessage('❌ Audio API test failed: ' + err.message, false, 'system');
                    });
                } catch (err) {
                    console.error('Audio API test error:', err);
                    addMessage('❌ Audio API error: ' + err.message, false, 'system');
                }
            });
        }
        
        // Log network request to dev tools
        function logNetworkRequest(type, url, message) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { type, url, message, timestamp };
            
            devMode.networkLogs.push(logEntry);
            
            // Keep only the last 50 logs
            if (devMode.networkLogs.length > 50) {
                devMode.networkLogs.shift();
            }
            
            // Update the log display
            const networkLog = document.getElementById('networkLog');
            
            // Clear if this is the first entry
            if (networkLog.textContent.includes('No requests logged yet')) {
                networkLog.innerHTML = '';
            }
            
            // Create log entry
            const entryDiv = document.createElement('div');
            entryDiv.style.borderBottom = '1px solid #374151';
            entryDiv.style.paddingBottom = '4px';
            entryDiv.style.marginBottom = '4px';
            
            // Set color based on type
            let typeColor = '#a0a0a0';
            if (type.includes('ERROR')) typeColor = '#ef4444';
            if (type === 'SUCCESS') typeColor = '#10b981';
            
            entryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between;">
                    <span style="color: ${typeColor};">${type}</span>
                    <span style="opacity: 0.7;">${timestamp}</span>
                </div>
                <div style="font-weight: bold;">${url}</div>
                <div style="word-break: break-all;">${message}</div>
            `;
            
            networkLog.appendChild(entryDiv);
            networkLog.scrollTop = networkLog.scrollHeight;
        }
        
        // Override fetch for network logging in dev mode
        const originalFetch = window.fetch;
        window.fetch = async function(url, options) {
            const startTime = performance.now();
            
            // Log the request
            if (devMode.showTimings) {
                logNetworkRequest('REQUEST', url, `Method: ${options?.method || 'GET'}`);
            }
            
            try {
                const response = await originalFetch(url, options);
                
                // Log the response
                if (devMode.showTimings) {
                    const endTime = performance.now();
                    const duration = Math.round(endTime - startTime);
                    logNetworkRequest('RESPONSE', url, `Status: ${response.status} (${duration}ms)`);
                }
                
                return response;
            } catch (error) {
                // Log the error
                if (devMode.showTimings) {
                    logNetworkRequest('FETCH_ERROR', url, `Error: ${error.message}`);
                }
                throw error;
            }
        };

        // WebSocket for real-time voice chat
        const socket = new WebSocket(`ws://${window.location.host}/ws/voice-chat`);
        let audioChunks = [];

        socket.onopen = () => {
            console.log('Connected to NIS voice backend');
            addMessage('✅ Connected to voice backend', false, 'system');
        };

        socket.onclose = () => {
            console.log('Disconnected from voice backend');
            addMessage('❌ Disconnected from voice backend', false, 'system');
        };

        socket.onmessage = (event) => {
            console.log('WebSocket message received:', event.data instanceof Blob ? 'Blob data' : event.data);
            
            if (event.data instanceof Blob) {
                console.log('Received audio chunk:', event.data.size, 'bytes');
                audioChunks.push(event.data);
                // Check for end (assuming backend sends a text message for 'end')
            } else {
                try {
                    console.log('Received JSON data:', event.data);
                    const data = JSON.parse(event.data);
                    
                    if (data.status === 'end') {
                        // Play audio with agent-specific voice settings
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        const audio = new Audio(URL.createObjectURL(audioBlob));
                        console.log('Playing audio blob:', audioBlob);
                        
                        // Apply agent-specific voice characteristics if available
                        if (data.agentId) {
                            const voiceConfig = agentUI.getAgentVoiceConfig(data.agentId);
                            // Note: HTML5 audio doesn't support pitch/rate, but we can use Web Speech API
                            agentUI.showAgentIndicator(data.agentId, 'speaking');
                        }
                        
                        audio.play();
                        audioChunks = [];
                        
                        // Hide speaking indicator when audio ends
                        audio.onended = () => {
                            agentUI.hideAgentIndicator();
                        };
                        
                        // Show performance metrics if available
                        if (data.processing_time_ms || data.tts_time_ms) {
                            const totalTime = (data.processing_time_ms || 0) + (data.tts_time_ms || 0);
                            console.log(`🚀 Performance: ${totalTime.toFixed(0)}ms total (STT+Agent+TTS)`);
                            
                            // Show performance indicator if under target
                            if (totalTime < 500) {
                                addMessage(`⚡ Ultra-fast response: ${totalTime.toFixed(0)}ms`, false, 'system');
                            }
                        }
                        
                    } else if (data.type === 'partial_transcription') {
                        // Show partial transcription in real-time
                        updatePartialTranscription(data.text, data.confidence);
                        
                    } else if (data.type === 'performance_stats') {
                        // Update performance dashboard
                        updatePerformanceStats(data.session_stats, data.buffer_status, data.stt_stats);
                        
                    } else if (data.type === 'latency_warning') {
                        // Show latency warning
                        addMessage(`⚠️ ${data.message} (${data.current_latency_ms.toFixed(0)}ms)`, false, 'system');
                        
                    } else if (data.type === 'wake_word_detected') {
                        // Handle wake word detection
                        handleWakeWordDetected(data);
                        
                    } else if (data.type === 'voice_command_detected') {
                        // Handle voice command detection
                        handleVoiceCommand(data);
                        
                    } else if (data.type === 'conversation_started') {
                        // Handle conversation session start
                        handleConversationStart(data);
                        
                    } else if (data.type === 'conversation_ended') {
                        // Handle conversation session end
                        handleConversationEnd(data);
                        
                    } else if (data.type === 'agent_switched') {
                        // Handle agent switching
                        handleAgentSwitch(data);
                        
                    } else if (data.type === 'help_response' || data.type === 'status_response') {
                        // Handle system responses
                        addMessage(data.text, false, 'system');
                        
                    } else if (data.agentHandoff) {
                        // Show agent handoff animation
                        agentUI.showAgentHandoff(data.agentHandoff.from, data.agentHandoff.to);
                        
                    } else if (data.agentThinking) {
                        // Show agent thinking indicator
                        agentUI.showAgentThinking(data.agentThinking);
                        
                    } else if (data.text) {
                        // Regular message with agent identification
                        const agentId = data.agentId || data.speaker || 'default';
                        agentUI.addAgentMessage(agentId, data.text, false);
                        agentUI.hideAgentThinking();
                        
                        // Show agent indicator
                        agentUI.showAgentIndicator(agentId, 'responded');
                    }
                } catch (e) {
                    console.error('Error parsing message:', e);
                }
            }
        };

        // Multi-Agent UI Manager
        class AgentUIManager {
            constructor() {
                this.currentAgent = null;
                this.agentQueue = [];
                this.agentConfig = {
                    consciousness: {
                        name: 'Consciousness Agent',
                        icon: '🧠',
                        voice: { rate: 0.9, pitch: 1.1, volume: 0.8 },
                        color: 'consciousness'
                    },
                    physics: {
                        name: 'Physics Validator',
                        icon: '⚛️',
                        voice: { rate: 0.8, pitch: 0.9, volume: 0.9 },
                        color: 'physics'
                    },
                    coordination: {
                        name: 'Coordination Agent',
                        icon: '🎯',
                        voice: { rate: 1.0, pitch: 1.0, volume: 0.8 },
                        color: 'coordination'
                    },
                    research: {
                        name: 'Research Engine',
                        icon: '🔬',
                        voice: { rate: 0.9, pitch: 0.95, volume: 0.85 },
                        color: 'research'
                    },
                    memory: {
                        name: 'Memory Agent',
                        icon: '💾',
                        voice: { rate: 0.85, pitch: 1.05, volume: 0.8 },
                        color: 'memory'
                    }
                };
            }

            showAgentIndicator(agentId, status = 'active') {
                this.hideAgentIndicator(); // Remove previous
                
                const agent = this.agentConfig[agentId] || {
                    name: 'AI Agent',
                    icon: '🤖',
                    color: 'default'
                };

                const indicator = document.createElement('div');
                indicator.className = `agent-indicator ${agent.color}`;
                indicator.id = 'currentAgentIndicator';
                indicator.innerHTML = `
                    <div class="agent-icon">${agent.icon}</div>
                    <div>
                        <div style="font-weight: 600;">${agent.name}</div>
                        <div style="font-size: 11px; opacity: 0.8;">${status}</div>
                    </div>
                `;

                document.body.appendChild(indicator);
                this.currentAgent = agentId;

                // Auto-hide after 5 seconds if not speaking
                if (status !== 'speaking') {
                    setTimeout(() => {
                        if (indicator.parentNode) {
                            indicator.remove();
                        }
                    }, 5000);
                }
            }

            hideAgentIndicator() {
                const existing = document.getElementById('currentAgentIndicator');
                if (existing) {
                    existing.remove();
                }
            }

            showAgentHandoff(fromAgent, toAgent) {
                const fromConfig = this.agentConfig[fromAgent] || { name: fromAgent, icon: '🤖' };
                const toConfig = this.agentConfig[toAgent] || { name: toAgent, icon: '🤖' };

                const handoff = document.createElement('div');
                handoff.className = 'agent-handoff';
                handoff.innerHTML = `
                    <span>${fromConfig.icon} ${fromConfig.name}</span>
                    <span class="handoff-arrow">→</span>
                    <span>${toConfig.icon} ${toConfig.name}</span>
                `;

                document.body.appendChild(handoff);

                // Remove after 3 seconds
                setTimeout(() => {
                    if (handoff.parentNode) {
                        handoff.remove();
                    }
                }, 3000);

                // Show new agent indicator
                this.showAgentIndicator(toAgent, 'processing');
            }

            showAgentThinking(agentId) {
                this.hideAgentThinking();
                
                const agent = this.agentConfig[agentId] || { name: 'AI Agent', icon: '🤖' };
                
                const thinking = document.createElement('div');
                thinking.className = 'agent-thinking';
                thinking.id = 'agentThinking';
                thinking.innerHTML = `${agent.icon} ${agent.name} thinking...`;

                document.body.appendChild(thinking);
            }

            hideAgentThinking() {
                const existing = document.getElementById('agentThinking');
                if (existing) {
                    existing.remove();
                }
            }

            getAgentVoiceConfig(agentId) {
                return this.agentConfig[agentId]?.voice || { rate: 0.9, pitch: 1.0, volume: 0.8 };
            }

            addAgentMessage(agentId, text, isUser = false) {
                const agent = this.agentConfig[agentId] || { name: 'AI Agent', color: 'default' };
                
                // Create message with agent styling
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'ai'} agent-${agent.color}`;
                
                const badge = `<span class="agent-badge ${agent.color}">${agent.name}</span>`;
                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${!isUser ? badge : ''}
                        ${text}
                    </div>
                    <div class="message-time">${new Date().toLocaleTimeString()}</div>
                `;

                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    chatMessages.appendChild(messageDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }

                return messageDiv;
            }
        }

        // Performance monitoring functions
        let partialTranscriptionElement = null;
        let performanceStatsElement = null;

        function updatePartialTranscription(text, confidence) {
            if (!partialTranscriptionElement) {
                partialTranscriptionElement = document.createElement('div');
                partialTranscriptionElement.className = 'partial-transcription';
                partialTranscriptionElement.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 20px;
                    right: 20px;
                    background: rgba(59, 130, 246, 0.1);
                    border: 1px solid rgba(59, 130, 246, 0.3);
                    border-radius: 10px;
                    padding: 10px;
                    font-size: 14px;
                    color: #3b82f6;
                    z-index: 1000;
                    opacity: 0.8;
                `;
                document.body.appendChild(partialTranscriptionElement);
            }

            const confidenceColor = confidence > 0.8 ? '#10b981' : confidence > 0.6 ? '#f59e0b' : '#ef4444';
            partialTranscriptionElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>🎤 "${text}"</span>
                    <span style="color: ${confidenceColor}; font-size: 12px;">
                        ${(confidence * 100).toFixed(0)}%
                    </span>
                </div>
            `;

            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (partialTranscriptionElement && partialTranscriptionElement.parentNode) {
                    partialTranscriptionElement.remove();
                    partialTranscriptionElement = null;
                }
            }, 3000);
        }

        function updatePerformanceStats(sessionStats, bufferStatus, sttStats) {
            if (!performanceStatsElement) {
                performanceStatsElement = document.createElement('div');
                performanceStatsElement.className = 'performance-stats';
                performanceStatsElement.style.cssText = `
                    position: fixed;
                    top: 260px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    border-radius: 10px;
                    padding: 12px;
                    font-size: 11px;
                    font-family: monospace;
                    z-index: 997;
                    min-width: 200px;
                `;
                document.body.appendChild(performanceStatsElement);
            }

            const latencyColor = sessionStats.avg_latency_ms < 300 ? '#10b981' : 
                                sessionStats.avg_latency_ms < 500 ? '#f59e0b' : '#ef4444';

            performanceStatsElement.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 8px;">⚡ Performance Monitor</div>
                <div>Avg Latency: <span style="color: ${latencyColor}">${sessionStats.avg_latency_ms.toFixed(0)}ms</span></div>
                <div>Chunks: ${sessionStats.chunks_processed}</div>
                <div>Buffer: ${bufferStatus.input_buffer_size}/${bufferStatus.processing_buffer_size}/${bufferStatus.output_buffer_size}</div>
                <div>Quality: ${bufferStatus.quality_level}</div>
                <div style="margin-top: 4px; font-size: 10px; opacity: 0.7;">
                    Target: <200ms | Max: <500ms
                </div>
            `;

            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (performanceStatsElement && performanceStatsElement.parentNode) {
                    performanceStatsElement.remove();
                    performanceStatsElement = null;
                }
            }, 10000);
        }

        // Voice command and wake word handling
        let conversationActive = false;
        let wakeWordIndicator = null;
        let conversationIndicator = null;

        function handleWakeWordDetected(data) {
            console.log('Wake word detected:', data);
            
            // Show wake word indicator
            if (!wakeWordIndicator) {
                wakeWordIndicator = document.createElement('div');
                wakeWordIndicator.className = 'wake-word-indicator';
                wakeWordIndicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    right: 20px;
                    background: linear-gradient(135deg, #10b981, #059669);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: 600;
                    z-index: 1001;
                    animation: wakeWordPulse 2s ease-in-out;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                `;
                document.body.appendChild(wakeWordIndicator);
            }

            wakeWordIndicator.innerHTML = `
                <span>👋</span>
                <span>Wake Word: "${data.phrase}"</span>
                <span style="font-size: 12px; opacity: 0.8;">${(data.confidence * 100).toFixed(0)}%</span>
            `;

            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes wakeWordPulse {
                    0%, 100% { transform: scale(1); opacity: 0.9; }
                    50% { transform: scale(1.05); opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            // Show message
            addMessage(data.message, false, 'system');

            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (wakeWordIndicator && wakeWordIndicator.parentNode) {
                    wakeWordIndicator.remove();
                    wakeWordIndicator = null;
                }
            }, 5000);
        }

        function handleVoiceCommand(data) {
            console.log('Voice command detected:', data);
            
            const command = data.command;
            const details = data.details;
            
            // Show command feedback
            let commandMessage = '';
            switch (command) {
                case 'switch_agent':
                    commandMessage = `🔄 Switching to ${details.agent.toUpperCase()} Agent`;
                    break;
                case 'stop':
                    commandMessage = '🛑 Stopping conversation';
                    break;
                case 'help':
                    commandMessage = '❓ Showing help';
                    break;
                case 'status':
                    commandMessage = '📊 Checking status';
                    break;
                default:
                    commandMessage = `🎙️ Command: ${command}`;
            }
            
            addMessage(commandMessage, false, 'system');
        }

        function handleConversationStart(data) {
            console.log('Conversation started:', data);
            conversationActive = true;
            
            // Show conversation indicator
            if (!conversationIndicator) {
                conversationIndicator = document.createElement('div');
                conversationIndicator.className = 'conversation-indicator';
                conversationIndicator.style.cssText = `
                    position: fixed;
                    top: 100px;
                    right: 20px;
                    background: linear-gradient(135deg, #3b82f6, #2563eb);
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: 600;
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    animation: conversationPulse 3s ease-in-out infinite;
                `;
                document.body.appendChild(conversationIndicator);
            }

            conversationIndicator.innerHTML = `
                <span style="animation: spin 2s linear infinite;">🎙️</span>
                <span>Continuous Mode</span>
            `;

            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes conversationPulse {
                    0%, 100% { opacity: 0.8; }
                    50% { opacity: 1; }
                }
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
            document.head.appendChild(style);

            addMessage(data.message, false, 'system');
        }

        function handleConversationEnd(data) {
            console.log('Conversation ended:', data);
            conversationActive = false;
            
            // Remove conversation indicator
            if (conversationIndicator && conversationIndicator.parentNode) {
                conversationIndicator.remove();
                conversationIndicator = null;
            }
            
            addMessage(data.message, false, 'system');
        }

        function handleAgentSwitch(data) {
            console.log('Agent switched:', data);
            addMessage(data.message, false, 'system');
        }

        // Initialize managers
        const agentUI = new AgentUIManager();
        // aiVoiceInput already initialized above

        // Voice Settings Modal Management
        class VoiceSettingsManager {
            constructor() {
                this.modal = document.getElementById('voiceSettingsModal');
                this.settings = {};
                this.init();
            }

            async init() {
                // Load current settings from backend
                try {
                    const response = await fetch('/voice/settings');
                    const data = await response.json();
                    this.settings = data;
                    this.populateModal();
                } catch (error) {
                    console.error('Failed to load voice settings:', error);
                }

                // Setup event listeners
                this.setupEventListeners();
            }

            setupEventListeners() {
                const settingsBtn = document.getElementById('voiceSettingsBtn');
                const modal = this.modal;
                const closeBtn = document.getElementById('closeVoiceSettings');
                const saveBtn = document.getElementById('saveVoiceSettings');
                const testBtns = document.querySelectorAll('.test-speaker-btn');

                settingsBtn?.addEventListener('click', () => this.openModal());
                closeBtn?.addEventListener('click', () => this.closeModal());
                saveBtn?.addEventListener('click', () => this.saveSettings());

                testBtns.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const speaker = e.target.dataset.speaker;
                        this.testSpeaker(speaker);
                    });
                });

                // Close modal when clicking outside
                modal?.addEventListener('click', (e) => {
                    if (e.target === modal) this.closeModal();
                });

                // Keyboard shortcut (Ctrl+Alt+S)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.altKey && e.key === 's') {
                        e.preventDefault();
                        this.openModal();
                    }
                });
            }

            populateModal() {
                if (!this.settings.available_speakers) return;

                // Populate speaker options
                const speakerSelect = document.getElementById('defaultSpeaker');
                if (speakerSelect) {
                    speakerSelect.innerHTML = '';
                    Object.entries(this.settings.available_speakers).forEach(([key, speaker]) => {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = speaker.name;
                        speakerSelect.appendChild(option);
                    });
                }

                // Set default values
                const speedSlider = document.getElementById('voiceSpeed');
                const pitchSlider = document.getElementById('voicePitch');
                const volumeSlider = document.getElementById('voiceVolume');

                if (speedSlider) speedSlider.value = this.settings.voice_parameters?.speed_range?.default || 1.0;
                if (pitchSlider) pitchSlider.value = this.settings.voice_parameters?.pitch_range?.default || 1.0;
                if (volumeSlider) volumeSlider.value = this.settings.voice_parameters?.volume_range?.default || 0.8;

                // Update display values
                this.updateSliderDisplays();
            }

            updateSliderDisplays() {
                const sliders = ['voiceSpeed', 'voicePitch', 'voiceVolume'];
                sliders.forEach(id => {
                    const slider = document.getElementById(id);
                    const display = document.getElementById(id + 'Value');
                    if (slider && display) {
                        display.textContent = slider.value;
                        slider.addEventListener('input', () => {
                            display.textContent = slider.value;
                        });
                    }
                });
            }

            openModal() {
                this.modal.style.display = 'flex';
                document.body.style.overflow = 'hidden';
            }

            closeModal() {
                this.modal.style.display = 'none';
                document.body.style.overflow = 'auto';
            }

            async saveSettings() {
                const settings = {
                    speed: parseFloat(document.getElementById('voiceSpeed').value),
                    pitch: parseFloat(document.getElementById('voicePitch').value),
                    volume: parseFloat(document.getElementById('voiceVolume').value),
                    default_speaker: document.getElementById('defaultSpeaker').value,
                    auto_voice_detection: document.getElementById('autoDetection').checked,
                    wake_word_enabled: document.getElementById('wakeWordEnabled').checked,
                    continuous_mode: document.getElementById('continuousMode').checked
                };

                try {
                    const response = await fetch('/voice/settings/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(settings)
                    });

                    const result = await response.json();
                    if (result.success) {
                        this.showToast('Voice settings saved successfully!', 'success');
                        this.closeModal();
                    } else {
                        this.showToast('Failed to save settings: ' + (result.detail || 'Unknown error'), 'error');
                    }
                } catch (error) {
                    this.showToast('Failed to save settings: ' + error.message, 'error');
                }
            }

            async testSpeaker(speaker) {
                const testText = document.getElementById('testText').value || 'Hello! This is a test of the voice system.';
                
                try {
                    const response = await fetch(`/voice/test-speaker/${speaker}?text=${encodeURIComponent(testText)}`);
                    
                    if (response.ok) {
                        const audio = new Audio();
                        audio.src = URL.createObjectURL(await response.blob());
                        audio.play();
                        this.showToast(`Testing ${speaker} voice...`, 'info');
                    } else {
                        this.showToast(`Failed to test ${speaker} voice`, 'error');
                    }
                } catch (error) {
                    this.showToast('Failed to test voice: ' + error.message, 'error');
                }
            }

            showToast(message, type = 'info') {
                // Create toast notification
                const toast = document.createElement('div');
                toast.className = `voice-toast voice-toast-${type}`;
                toast.textContent = message;
                
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.classList.add('voice-toast-show');
                }, 100);
                
                setTimeout(() => {
                    toast.classList.remove('voice-toast-show');
                    setTimeout(() => toast.remove(), 300);
                }, 3000);
            }
        }

        // Initialize voice settings manager
        const voiceSettings = new VoiceSettingsManager();

        // ===== 🔥 QUICK ACTION FUNCTIONS (Global) =====
        
        window.clearChat = function() {
            const chatMessages = document.getElementById('chatMessages');
            if (chatMessages && confirm('Are you sure you want to clear the chat?')) {
                chatMessages.innerHTML = '';
                addMessage('🗑️ Chat cleared!', false, 'system');
                console.log('✅ Chat cleared');
            }
        };

        window.exportChat = function() {
            const chatMessages = document.getElementById('chatMessages');
            if (!chatMessages) return;
            
            const messages = Array.from(chatMessages.querySelectorAll('.message')).map(msg => {
                const role = msg.classList.contains('user-message') ? 'User' : 
                           msg.classList.contains('assistant-message') ? 'Assistant' : 'System';
                const content = msg.textContent || msg.innerText;
                return `[${role}] ${content}`;
            }).join('\n\n');
            
            const blob = new Blob([messages], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `nis-modern-chat-${new Date().toISOString().slice(0,10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            addMessage('💾 Chat exported successfully!', false, 'system');
            console.log('✅ Chat exported');
        };

        window.runCodeDemo = async function() {
            addMessage('💻 Running code execution demo...', false, 'system');
            
            const demoCode = `# Calculate Fibonacci numbers
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# Calculate first 10 fibonacci numbers
result = [fibonacci(i) for i in range(10)]
print("First 10 Fibonacci numbers:", result)
print("Sum:", sum(result))`;
            
            try {
                const response = await fetch('/execute/code', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        code: demoCode,
                        language: 'python'
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    addMessage(`✅ **Code Execution Result:**\n\n\`\`\`\n${result.stdout}\n\`\`\`\n\n⏱️ Execution time: ${result.execution_time || 0}ms`, false);
                } else {
                    addMessage(`❌ **Execution Error:**\n\n\`\`\`\n${result.stderr || result.error}\n\`\`\``, false);
                }
            } catch (error) {
                addMessage(`❌ Code execution failed: ${error.message}`, false, 'system');
            }
        };

        window.runPhysicsDemo = async function() {
            addMessage('🔬 Running TRUE PINN physics validation demo...', false, 'system');
            
            try {
                const response = await fetch('/physics/validate/true-pinn', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        scenario: 'bouncing_ball',
                        mode: 'true_pinn',
                        domain: 'classical_mechanics',
                        parameters: {
                            initial_height: 10.0,
                            gravity: 9.81,
                            elasticity: 0.8
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.valid !== undefined) {
                    let message = `## 🔬 Physics Validation Complete\n\n`;
                    message += `**Status:** ${result.valid ? '✅ Valid' : '❌ Invalid'}\n`;
                    message += `**Physics Compliance:** ${(result.confidence * 100).toFixed(1)}%\n`;
                    message += `**Mode:** ${result.mode || 'TRUE_PINN'}\n`;
                    message += `**Execution Time:** ${result.execution_time?.toFixed(3)}s\n\n`;
                    
                    if (result.validation_details) {
                        message += `### Validation Details\n`;
                        message += `\`\`\`json\n${JSON.stringify(result.validation_details, null, 2)}\n\`\`\``;
                    }
                    
                    addMessage(message, false);
                } else {
                    addMessage(`🔬 Physics validation response:\n\n\`\`\`json\n${JSON.stringify(result, null, 2)}\n\`\`\``, false);
                }
            } catch (error) {
                addMessage(`❌ Physics demo failed: ${error.message}`, false, 'system');
            }
        };

        window.runDeepResearch = async function() {
            const query = prompt('🔬 Enter your research query:');
            if (!query) return;
            
            addMessage(`🔬 Deep Research: ${query}`, true);
            addMessage('🔍 Conducting comprehensive research...', false, 'system');
            
            try {
                const response = await fetch('/research/deep', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: query,
                        research_depth: 'comprehensive',
                        include_sources: true
                    })
                });
                
                const result = await response.json();
                
                if (result.research_result) {
                    let message = `## 📚 Deep Research Results\n\n`;
                    message += result.research_result;
                    
                    if (result.sources && result.sources.length > 0) {
                        message += `\n\n### 📖 Sources\n`;
                        result.sources.forEach((source, i) => {
                            message += `${i + 1}. ${source.title || source.url || source}\n`;
                        });
                    }
                    
                    addMessage(message, false);
                } else {
                    addMessage(`📚 Research response:\n\n${JSON.stringify(result, null, 2)}`, false);
                }
            } catch (error) {
                addMessage(`❌ Research failed: ${error.message}`, false, 'system');
            }
        };

        window.showKeyboardShortcuts = function() {
            const shortcuts = `## ⌨️ Keyboard Shortcuts

**Chat Controls:**
- \`Ctrl+Enter\` - Send message
- \`Escape\` - Clear input
- \`Ctrl+L\` - Clear chat

**Voice Controls:**
- \`Ctrl+M\` - Toggle voice mode
- \`Space\` - Start/stop recording (when in voice mode)

**Quick Actions:**
- \`Ctrl+E\` - Export chat
- \`Ctrl+K\` - Show this help

**Tips:**
- Use Smart Consensus for best responses
- Try VibeVoice for AI agent personalities
- Export important chats regularly`;
            
            addMessage(shortcuts, false, 'system');
        };

        console.log('✅ Quick action functions initialized');
    </script>

    <!-- Voice Settings Modal -->
    <div id="voiceSettingsModal" class="voice-settings-modal" style="display: none;">
        <div class="voice-settings-content">
            <div class="voice-settings-header">
                <h2>🎛️ Voice Settings</h2>
                <button id="closeVoiceSettings" class="close-btn">×</button>
            </div>
            
            <div class="voice-settings-body">
                <!-- Speaker Selection -->
                <div class="settings-section">
                    <h3>🎤 Speaker Selection</h3>
                    <div class="setting-item">
                        <label for="defaultSpeaker">Default Speaker:</label>
                        <select id="defaultSpeaker">
                            <option value="consciousness">Consciousness Agent</option>
                            <option value="physics">Physics Agent</option>
                            <option value="research">Research Agent</option>
                            <option value="coordination">Coordination Agent</option>
                        </select>
                    </div>
                </div>

                <!-- Voice Parameters -->
                <div class="settings-section">
                    <h3>🎚️ Voice Parameters</h3>
                    
                    <div class="setting-item">
                        <label for="voiceSpeed">Speed: <span id="voiceSpeedValue">1.0</span></label>
                        <input type="range" id="voiceSpeed" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="setting-item">
                        <label for="voicePitch">Pitch: <span id="voicePitchValue">1.0</span></label>
                        <input type="range" id="voicePitch" min="0.5" max="2.0" step="0.1" value="1.0">
                    </div>
                    
                    <div class="setting-item">
                        <label for="voiceVolume">Volume: <span id="voiceVolumeValue">0.8</span></label>
                        <input type="range" id="voiceVolume" min="0.0" max="1.0" step="0.05" value="0.8">
                    </div>
                </div>

                <!-- Conversation Settings -->
                <div class="settings-section">
                    <h3>💬 Conversation Settings</h3>
                    
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="autoDetection" checked>
                            Auto Voice Detection
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="wakeWordEnabled" checked>
                            Wake Word ("Hey NIS")
                        </label>
                    </div>
                    
                    <div class="setting-item">
                        <label>
                            <input type="checkbox" id="continuousMode" checked>
                            Continuous Conversation Mode
                        </label>
                    </div>
                </div>

                <!-- Voice Testing -->
                <div class="settings-section">
                    <h3>🧪 Voice Testing</h3>
                    
                    <div class="setting-item">
                        <label for="testText">Test Text:</label>
                        <input type="text" id="testText" placeholder="Hello! This is a test of the voice system." value="Hello! This is a test of the voice system.">
                    </div>
                    
                    <div class="speaker-test-buttons">
                        <button class="test-speaker-btn" data-speaker="consciousness">Test Consciousness</button>
                        <button class="test-speaker-btn" data-speaker="physics">Test Physics</button>
                        <button class="test-speaker-btn" data-speaker="research">Test Research</button>
                        <button class="test-speaker-btn" data-speaker="coordination">Test Coordination</button>
                    </div>
                </div>

                <!-- Keyboard Shortcuts -->
                <div class="settings-section">
                    <h3>⌨️ Keyboard Shortcuts</h3>
                    <div class="shortcuts-list">
                        <div class="shortcut-item">
                            <span class="shortcut-key">Ctrl+V</span>
                            <span class="shortcut-desc">Toggle Voice Chat</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-key">Ctrl+Space</span>
                            <span class="shortcut-desc">Push to Talk</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-key">Escape</span>
                            <span class="shortcut-desc">Stop Voice</span>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-key">Ctrl+Alt+S</span>
                            <span class="shortcut-desc">Open Settings</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="voice-settings-footer">
                <button id="saveVoiceSettings" class="save-btn">💾 Save Settings</button>
                <button id="closeVoiceSettings" class="cancel-btn">Cancel</button>
            </div>
        </div>
    </div>

    <style>
        /* Voice Settings Modal Styles */
        .voice-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .voice-settings-content {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 15px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            color: #e2e8f0;
        }

        .voice-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid #475569;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            border-radius: 15px 15px 0 0;
        }

        .voice-settings-header h2 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            color: #e2e8f0;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.1);
        }

        .voice-settings-body {
            padding: 25px;
        }

        .settings-section {
            margin-bottom: 30px;
        }

        .settings-section h3 {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            color: #60a5fa;
            border-bottom: 1px solid #475569;
            padding-bottom: 8px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #cbd5e1;
        }

        .setting-item input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #475569;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .setting-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .setting-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .setting-item select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #475569;
            border-radius: 8px;
            background: #334155;
            color: #e2e8f0;
            font-size: 14px;
        }

        .setting-item input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #475569;
            border-radius: 8px;
            background: #334155;
            color: #e2e8f0;
            font-size: 14px;
        }

        .setting-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .speaker-test-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .test-speaker-btn {
            padding: 8px 16px;
            border: 1px solid #3b82f6;
            border-radius: 8px;
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .test-speaker-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            transform: translateY(-1px);
        }

        .shortcuts-list {
            display: grid;
            gap: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        .shortcut-key {
            background: #475569;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }

        .shortcut-desc {
            color: #94a3b8;
            font-size: 13px;
        }

        .voice-settings-footer {
            padding: 20px 25px;
            border-top: 1px solid #475569;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 0 0 15px 15px;
        }

        .save-btn, .cancel-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .save-btn {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
            color: white;
        }

        .save-btn:hover {
            background: linear-gradient(135deg, #15803d 0%, #166534 100%);
            transform: translateY(-1px);
        }

        .cancel-btn {
            background: rgba(255, 255, 255, 0.1);
            color: #e2e8f0;
        }

        .cancel-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Toast Notifications */
        .voice-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 10001;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .voice-toast-show {
            transform: translateX(0);
        }

        .voice-toast-success {
            background: linear-gradient(135deg, #16a34a 0%, #15803d 100%);
        }

        .voice-toast-error {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        .voice-toast-info {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .voice-settings-content {
                width: 95%;
                margin: 10px;
                max-height: 95vh;
            }
            
            .speaker-test-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</body>
</html>
